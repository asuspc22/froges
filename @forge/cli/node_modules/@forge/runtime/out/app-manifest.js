"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppManifest = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const t = tslib_1.__importStar(require("io-ts"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = require("url");
const bearerMethodShorthands = t.union([
    t.literal('authorization-header'),
    t.literal('form-encoded'),
    t.literal('uri-query')
]);
const bearerMethodOptions = t.intersection([
    t.interface({
        type: bearerMethodShorthands
    }),
    t.partial({
        parameter: t.string,
        prefix: t.string
    })
]);
const bearerMethodFields = t.union([bearerMethodShorthands, bearerMethodOptions]);
const AuthProviderCheckedType = t.interface({
    key: t.string,
    bearerMethod: bearerMethodFields,
    remotes: t.array(t.string)
});
const urlString = new t.Type('string', (input) => typeof input === 'string' && new url_1.URL(input) && true, (input, context) => (typeof input === 'string' ? t.success(input) : t.failure(input, context)), t.identity);
const AppManifestOptionalFields = t.partial({
    egress: t.array(t.string),
    remotes: t.array(t.interface({
        key: t.string,
        baseUrl: urlString
    })),
    providers: t.interface({
        auth: t.array(AuthProviderCheckedType)
    })
});
const AppManifestRequiredFields = t.interface({
    app: t.interface({
        id: t.string
    })
});
const AppManifestType = t.intersection([AppManifestRequiredFields, AppManifestOptionalFields]);
class AppManifest {
    constructor(manifest) {
        if (!AppManifestType.is(manifest)) {
            throw new Error('invalid manifest');
        }
        else {
            this.manifest = manifest;
        }
    }
    static async fromFile(filePath) {
        const fullPath = path_1.default.join(filePath, AppManifest.FILE_NAME);
        const manifestContents = (0, fs_1.readFileSync)(fullPath, 'utf-8');
        const manifest = js_yaml_1.default.safeLoad(manifestContents);
        return new AppManifest(manifest);
    }
    getHostForRemote(remote) {
        var _a;
        const found = (_a = this.manifest.remotes) === null || _a === void 0 ? void 0 : _a.find(({ key }) => key === remote);
        return found === null || found === void 0 ? void 0 : found.baseUrl;
    }
    getDefaultRemoteForProvider(provider) {
        var _a;
        const providerConfig = (_a = this.manifest.providers) === null || _a === void 0 ? void 0 : _a.auth.find((v) => v.key === provider);
        const remotes = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.remotes;
        if (remotes && remotes.length > 0) {
            return remotes[0];
        }
        return undefined;
    }
    getExternalAuthProviderConfig(provider) {
        var _a;
        return (_a = this.manifest.providers) === null || _a === void 0 ? void 0 : _a.auth.find((v) => v.key === provider);
    }
    getEgressAllowlist() {
        return this.manifest.egress || [];
    }
}
exports.AppManifest = AppManifest;
AppManifest.FILE_NAME = 'manifest.yml';
