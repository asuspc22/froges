import * as t from 'io-ts';
declare const bearerMethodShorthands: t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>;
export declare type BearerMethods = t.TypeOf<typeof bearerMethodShorthands>;
declare const bearerMethodOptions: t.IntersectionC<[t.TypeC<{
    type: t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>;
}>, t.PartialC<{
    parameter: t.StringC;
    prefix: t.StringC;
}>]>;
declare const bearerMethodFields: t.UnionC<[t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>, t.IntersectionC<[t.TypeC<{
    type: t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>;
}>, t.PartialC<{
    parameter: t.StringC;
    prefix: t.StringC;
}>]>]>;
export declare type BearerMethodOptions = t.TypeOf<typeof bearerMethodOptions>;
export declare type DefaultBearerMethodParameters = {
    parameter: string;
    prefix: string;
};
export declare type BearerMethodFields = t.TypeOf<typeof bearerMethodFields>;
declare const AuthProviderCheckedType: t.TypeC<{
    key: t.StringC;
    bearerMethod: t.UnionC<[t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>, t.IntersectionC<[t.TypeC<{
        type: t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>;
    }>, t.PartialC<{
        parameter: t.StringC;
        prefix: t.StringC;
    }>]>]>;
    remotes: t.ArrayC<t.StringC>;
}>;
export declare type AuthProviderType = t.TypeOf<typeof AuthProviderCheckedType>;
declare const AppManifestType: t.IntersectionC<[t.TypeC<{
    app: t.TypeC<{
        id: t.StringC;
    }>;
}>, t.PartialC<{
    egress: t.ArrayC<t.StringC>;
    remotes: t.ArrayC<t.TypeC<{
        key: t.StringC;
        baseUrl: t.Type<string, string, unknown>;
    }>>;
    providers: t.TypeC<{
        auth: t.ArrayC<t.TypeC<{
            key: t.StringC;
            bearerMethod: t.UnionC<[t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>, t.IntersectionC<[t.TypeC<{
                type: t.UnionC<[t.LiteralC<"authorization-header">, t.LiteralC<"form-encoded">, t.LiteralC<"uri-query">]>;
            }>, t.PartialC<{
                parameter: t.StringC;
                prefix: t.StringC;
            }>]>]>;
            remotes: t.ArrayC<t.StringC>;
        }>>;
    }>;
}>]>;
export interface EgressControl {
    getEgressAllowlist(): string[];
}
export declare type AppManifestDefinition = t.TypeOf<typeof AppManifestType>;
export declare class AppManifest implements EgressControl {
    static FILE_NAME: string;
    static fromFile(filePath: string): Promise<AppManifest>;
    manifest: AppManifestDefinition;
    constructor(manifest: AppManifestDefinition);
    getHostForRemote(remote: string): undefined | string;
    getDefaultRemoteForProvider(provider: string): undefined | string;
    getExternalAuthProviderConfig(provider: string): undefined | AuthProviderType;
    getEgressAllowlist(): string[];
}
export {};
//# sourceMappingURL=app-manifest.d.ts.map