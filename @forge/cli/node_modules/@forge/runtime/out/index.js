"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invoke = exports.validateInvocation = exports.InvocationValidationError = exports.getUserVars = exports.initializeInspector = void 0;
const tslib_1 = require("tslib");
const Either_1 = require("fp-ts/lib/Either");
const io_ts_reporters_1 = require("io-ts-reporters");
const request_1 = require("./request");
const inspector_1 = require("./sandbox/inspector");
tslib_1.__exportStar(require("./app-manifest"), exports);
tslib_1.__exportStar(require("./config"), exports);
tslib_1.__exportStar(require("./context"), exports);
tslib_1.__exportStar(require("./feature-flag"), exports);
tslib_1.__exportStar(require("./metrics"), exports);
tslib_1.__exportStar(require("./request"), exports);
tslib_1.__exportStar(require("./result"), exports);
tslib_1.__exportStar(require("./snapshot"), exports);
tslib_1.__exportStar(require("./limits"), exports);
tslib_1.__exportStar(require("./logger"), exports);
tslib_1.__exportStar(require("./sandbox"), exports);
function initializeInspector() {
    return new inspector_1.ChromeInspector();
}
exports.initializeInspector = initializeInspector;
function getUserVars() {
    const prefix = 'FORGE_USER_VAR_';
    const envKeys = Object.keys(process.env);
    return envKeys.reduce((userVars, name) => {
        if (name.startsWith(prefix)) {
            userVars.push({
                key: name.substring(prefix.length),
                value: String(process.env[name]),
                secure: false
            });
        }
        return userVars;
    }, []);
}
exports.getUserVars = getUserVars;
class InvocationValidationError extends Error {
}
exports.InvocationValidationError = InvocationValidationError;
function failedInvocationMessage(validationResult) {
    return ['Invocation validation failed:', ...(0, io_ts_reporters_1.reporter)(validationResult)].join('\n');
}
function validateInvocation(invocation) {
    const validationResult = request_1.ExternalRequestBodyType.decode(invocation);
    if ((0, Either_1.isLeft)(validationResult)) {
        throw new InvocationValidationError(failedInvocationMessage(validationResult));
    }
    else {
        return validationResult.right;
    }
}
exports.validateInvocation = validateInvocation;
function invoke(invocation) {
    return invocation.sandbox.execute(invocation.xenInvocationRequest, invocation.invocationLimits, invocation.inspector);
}
exports.invoke = invoke;
