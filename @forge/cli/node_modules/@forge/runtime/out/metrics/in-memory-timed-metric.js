"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryTimedMetric = void 0;
const MILLISEC_TO_NANOSEC = 1000000;
class InMemoryTimedMetric {
    constructor(name, additionalInfo) {
        this.name = name;
        this.additionalInfo = additionalInfo;
        this.latency = 0;
        this.started = false;
        this.startedAt = BigInt(0);
    }
    getTime() {
        if (this.started) {
            this.stopTimer();
        }
        return this.format(this.latency);
    }
    getName() {
        return this.name;
    }
    getTags() {
        return this.additionalInfo || {};
    }
    format(input, opts) {
        return parseFloat(input.toFixed((opts === null || opts === void 0 ? void 0 : opts.precision) || 2));
    }
    stopTimer(extraTags) {
        const latency = process.hrtime.bigint() - this.startedAt;
        this.started = false;
        this.set(Number(latency) / MILLISEC_TO_NANOSEC, extraTags);
    }
    measure() {
        this.startedAt = process.hrtime.bigint();
        this.started = true;
        return {
            stop: (extraTags, opts) => {
                this.stopTimer(extraTags);
                return this.format(this.latency, opts);
            }
        };
    }
    set(val, extraTags) {
        this.latency = val;
        if (extraTags) {
            this.additionalInfo = Object.assign(Object.assign({}, this.additionalInfo), extraTags);
        }
    }
}
exports.InMemoryTimedMetric = InMemoryTimedMetric;
