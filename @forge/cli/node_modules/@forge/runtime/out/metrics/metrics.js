"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMetricsCollector = exports.MetricsCollector = exports.MetricType = exports.InMemoryMetrics = void 0;
const metrics_interface_1 = require("@forge/util/packages/metrics-interface");
const feature_flag_1 = require("../feature-flag");
const in_memory_metrics_1 = require("./in-memory-metrics");
Object.defineProperty(exports, "InMemoryMetrics", { enumerable: true, get: function () { return in_memory_metrics_1.InMemoryMetrics; } });
var MetricType;
(function (MetricType) {
    MetricType["TimerMetric"] = "timer";
    MetricType["CounterMetric"] = "counter";
    MetricType["GaugeMetric"] = "gauge";
    MetricType["EventMetric"] = "event";
})(MetricType = exports.MetricType || (exports.MetricType = {}));
class MetricsCollector {
    constructor(_metrics) {
        this._metrics = _metrics;
    }
    metrics() {
        return this._metrics;
    }
    collectMetrics() {
        return MetricsCollector.collect(this._metrics);
    }
    static collect(metrics, prefix = undefined) {
        if (!(metrics instanceof in_memory_metrics_1.InMemoryMetrics)) {
            return [];
        }
        const addPrefix = (p, value) => {
            return p ? p + '.' + value : value;
        };
        const allMetrics = Array.from(metrics.getChildren().entries())
            .map(([k, v]) => [...MetricsCollector.collect(v, addPrefix(prefix, k))])
            .reduce((accumulator, value) => accumulator.concat(value), []);
        const counters = Array.from(metrics.getCounters().values()).map((v) => ({
            name: addPrefix(prefix, v.getName()),
            tags: v.getTags(),
            type: MetricType.CounterMetric,
            value: v.getCount()
        }));
        const gauges = Array.from(metrics.getGauges().values()).map((v) => ({
            name: addPrefix(prefix, v.getName()),
            tags: v.getTags(),
            type: MetricType.GaugeMetric,
            value: v.getValue()
        }));
        const timers = metrics.getTimers().map((v) => ({
            name: addPrefix(prefix, v.getName()),
            tags: v.getTags(),
            type: MetricType.TimerMetric,
            value: v.getTime()
        }));
        const events = metrics.getEvents().map((v) => ({
            name: addPrefix(prefix, v.getName()),
            tags: v.getTags(),
            type: MetricType.EventMetric,
            value: v.getDescription()
        }));
        allMetrics.push(...timers, ...counters, ...gauges, ...events);
        return allMetrics;
    }
    async wrapInMetrics(options, callback) {
        this._metrics.counter(options.name, options.tags).incr();
        const timer = this._metrics.timing(options.name, options.tags).measure();
        try {
            return await callback();
        }
        finally {
            timer.stop();
        }
    }
}
exports.MetricsCollector = MetricsCollector;
const createMetricsCollector = (xenInvocationRequest) => {
    const shouldReportMetrics = xenInvocationRequest.isFeatureFlagEnabled(feature_flag_1.XEN_RUNTIME_SHOULD_REPORT_METRICS);
    const metrics = shouldReportMetrics ? new in_memory_metrics_1.InMemoryMetrics() : new metrics_interface_1.NoMetrics();
    return {
        collector: new MetricsCollector(metrics),
        enabled: shouldReportMetrics
    };
};
exports.createMetricsCollector = createMetricsCollector;
