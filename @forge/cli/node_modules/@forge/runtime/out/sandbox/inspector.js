"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplementedInspector = exports.ChromeInspector = exports.SETUP_METHODS = void 0;
const tslib_1 = require("tslib");
const ws_1 = tslib_1.__importDefault(require("ws"));
const util_1 = require("util");
const CLOSE_CONNECTION_ON_SESSION_STOP = false;
const VERBOSE_LOG = false;
const INSPECTOR_SUBTYPE_DETECTORS = {
    null: (a) => a === null,
    array: Array.isArray,
    date: (a) => a instanceof Date,
    error: (a) => a instanceof Error,
    regexp: (a) => a instanceof RegExp
};
const inspectorSubtypeEntries = Object.entries(INSPECTOR_SUBTYPE_DETECTORS);
exports.SETUP_METHODS = [
    'Profiler.enable',
    'Runtime.enable',
    'Debugger.enable',
    'Debugger.setPauseOnExceptions',
    'Debugger.setAsyncCallStackDepth',
    'Runtime.getIsolateId',
    'Debugger.setBlackboxPatterns',
    'Runtime.runIfWaitingForDebugger'
];
const isMessageForNewSandbox = (message) => {
    const msg = JSON.parse(message);
    const { method } = msg;
    if (!method) {
        return false;
    }
    if (exports.SETUP_METHODS.includes(method)) {
        return true;
    }
    return (method.startsWith('Debugger.') &&
        method.toLowerCase().includes('breakpoint') &&
        method !== 'Debugger.getPossibleBreakpoints');
};
function log(...args) {
    console.log('[Inspector]', ...args);
}
function processArgForLogConsole(arg) {
    const type = typeof arg;
    if (type === 'undefined') {
        return { type };
    }
    if (arg === null) {
        return {
            type,
            subtype: 'null',
            value: null
        };
    }
    if (type === 'number' && (isNaN(arg) || !isFinite(arg))) {
        const description = arg.toString();
        return {
            type,
            unserializableValue: description,
            description
        };
    }
    const className = type === 'object' ? arg.constructor.name : undefined;
    const subtype = inspectorSubtypeEntries.find((a) => a[1](arg));
    return Object.assign(Object.assign(Object.assign({ type }, (className ? { className } : undefined)), (subtype ? { subtype: subtype[0] } : undefined)), { value: arg, description: (0, util_1.inspect)(arg) });
}
class ChromeInspector {
    constructor() {
        this.frontendMsgsForNewSandbox = [];
        this.sendMessageToFrontend = (message) => {
            const wss = this.wss;
            if (!wss) {
                return;
            }
            if (VERBOSE_LOG) {
                log('Message to frontend:\n' + message);
            }
            wss.clients.forEach((ws) => ws.send(message));
        };
        this.stopSession = () => {
            const wss = this.wss;
            if (!wss) {
                return;
            }
            if (CLOSE_CONNECTION_ON_SESSION_STOP) {
                wss.clients.forEach((ws) => ws.close());
            }
            const callbacks = this.callbacks;
            if (!callbacks) {
                return;
            }
            this.callbacks = undefined;
            callbacks.onSessionStop();
        };
    }
    startServer(port = 0) {
        const wss = new ws_1.default.Server({ port });
        wss.on('connection', (ws) => {
            if (wss.clients.size > 1) {
                ws.close(ChromeInspector.DENY_CODE, ChromeInspector.DENY_REASON);
                log(ChromeInspector.DENY_REASON);
                return;
            }
            if (VERBOSE_LOG) {
                log('Frontend connected');
            }
            ws.on('error', (err) => {
                log('Error', err);
                this.stopSession();
            });
            ws.on('close', () => {
                if (VERBOSE_LOG) {
                    log('Frontend closed');
                }
                this.frontendMsgsForNewSandbox = [];
                this.stopSession();
            });
            ws.on('message', (message) => {
                if (this.callbacks) {
                    this.addMessageForNewSandbox(message, true);
                    this.callbacks.onMessageFromFrontend(message);
                }
                else {
                    this.addMessageForNewSandbox(message, false);
                }
            });
        });
        this.wss = wss;
        return `127.0.0.1:${this.getWebsocketPort()}`;
    }
    stopServer() {
        const wss = this.wss;
        if (!wss) {
            return Promise.resolve();
        }
        this.stopSession();
        return new Promise((resolve, reject) => {
            wss.close((error) => {
                this.wss = undefined;
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    isServerStopped() {
        return !this.wss;
    }
    startSession(callbacksSupplier) {
        if (!this.wss || this.wss.clients.size === 0) {
            return undefined;
        }
        if (this.callbacks) {
            return undefined;
        }
        const controls = {
            sendMessageToFrontend: this.sendMessageToFrontend,
            stopSession: this.stopSession
        };
        this.callbacks = callbacksSupplier(controls);
        this.forceResetFrontendState();
        this.deliverMessagesForNewSandbox();
        return controls;
    }
    logConsole(method, ...args) {
        if (!this.wss || this.wss.clients.size === 0) {
            return undefined;
        }
        let chromeLevel;
        switch (method) {
            case 'debug':
                chromeLevel = 'verbose';
                break;
            case 'warn':
                chromeLevel = 'warning';
                break;
            default:
                chromeLevel = method;
        }
        const message = {
            method: 'Runtime.consoleAPICalled',
            params: {
                type: chromeLevel,
                timestamp: Date.now(),
                args: args.map(processArgForLogConsole)
            }
        };
        this.sendMessageToFrontend(JSON.stringify(message));
    }
    getWebsocketPort() {
        const wss = this.wss;
        if (!wss) {
            throw Error('Inspector server not started');
        }
        const address = wss.address();
        if (address && address.port) {
            return address.port;
        }
        else {
            throw Error('Unable to find port for inspector server');
        }
    }
    forceResetFrontendState() {
        for (const evt of ChromeInspector.FORCE_RESET_FRONTEND_STATE_EVENTS) {
            this.sendMessageToFrontend(evt);
        }
    }
    addMessageForNewSandbox(message, inspecting) {
        const shouldAdd = isMessageForNewSandbox(message);
        if (shouldAdd) {
            this.frontendMsgsForNewSandbox.push(message);
        }
        if (VERBOSE_LOG) {
            log(`Message from frontend, inspecting = ${inspecting}, added for new sandbox = ${shouldAdd}:\n${message}`);
        }
    }
    deliverMessagesForNewSandbox() {
        const callbacks = this.callbacks;
        if (!callbacks) {
            return;
        }
        if (VERBOSE_LOG) {
            log('Messages for new sandbox', this.frontendMsgsForNewSandbox);
        }
        for (const msg of this.frontendMsgsForNewSandbox) {
            callbacks.onMessageFromFrontend(msg);
        }
    }
}
exports.ChromeInspector = ChromeInspector;
ChromeInspector.DENY_CODE = 1011;
ChromeInspector.DENY_REASON = 'Only one frontend is allowed';
ChromeInspector.FORCE_RESET_FRONTEND_STATE_EVENTS = [
    '{"method":"Runtime.executionContextsCleared"}',
    '{"method":"Inspector.targetReloadedAfterCrash"}'
];
exports.notImplementedInspector = {
    startServer: () => {
        throw new Error('Not implemented');
    },
    stopServer: async () => void 0,
    isServerStopped: () => true,
    startSession: () => {
        throw new Error('Not implemented');
    },
    logConsole: () => {
        throw new Error('Not implemented');
    }
};
