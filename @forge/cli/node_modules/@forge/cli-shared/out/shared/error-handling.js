"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationCompileError = exports.BundlerTSError = exports.ValidationError = exports.isErrorWithAnalytics = exports.assertIsError = exports.wrapError = exports.exitOnError = exports.HiddenError = exports.UserError = exports.BaseError = void 0;
const tslib_1 = require("tslib");
const ui_1 = require("../ui");
const Sentry = tslib_1.__importStar(require("@sentry/node"));
class BaseError extends Error {
    constructor(requestId, message) {
        super(message);
        this.requestId = requestId;
    }
    getAttributes() {
        return {
            isUserError: this.isUserError(),
            requestId: this.requestId
        };
    }
    isUserError() {
        return false;
    }
}
exports.BaseError = BaseError;
class UserError extends BaseError {
    constructor(message, requestId) {
        super(requestId, message);
    }
    isUserError() {
        return true;
    }
}
exports.UserError = UserError;
class HiddenError extends BaseError {
    constructor(message, requestId) {
        super(requestId, message);
    }
}
exports.HiddenError = HiddenError;
function removePrefixFromErrorMessage(message) {
    if (message.startsWith('error: ')) {
        return message.replace('error: ', '');
    }
    return message;
}
const exitOnError = async (logger, error, hint) => {
    let exitCode = 0;
    if (error) {
        Sentry.captureException(error);
        error.message = removePrefixFromErrorMessage(error.message);
        if (!(error instanceof HiddenError))
            logger.error(error);
        if (hint === undefined && !logger.debugEnabled) {
            hint = ui_1.Text.rerunningWithVerbose;
        }
        if (hint) {
            logger.info(hint);
        }
        exitCode = 1;
    }
    await Sentry.close();
    process.exit(exitCode);
};
exports.exitOnError = exitOnError;
const wrapError = (error) => {
    if (error instanceof Error) {
        return error;
    }
    return new Error(JSON.stringify(error));
};
exports.wrapError = wrapError;
const assertIsError = (error) => {
    if (!(error instanceof Error)) {
        throw new Error(`A non Error type object ${JSON.stringify(error)} of type '${typeof error}' was thrown.`);
    }
};
exports.assertIsError = assertIsError;
const isErrorWithAnalytics = (e) => {
    return e.getAttributes !== undefined;
};
exports.isErrorWithAnalytics = isErrorWithAnalytics;
class ValidationError extends UserError {
}
exports.ValidationError = ValidationError;
class BundlerTSError extends UserError {
}
exports.BundlerTSError = BundlerTSError;
class ApplicationCompileError extends UserError {
    constructor(error) {
        super(error.message);
        this.error = error;
    }
}
exports.ApplicationCompileError = ApplicationCompileError;
