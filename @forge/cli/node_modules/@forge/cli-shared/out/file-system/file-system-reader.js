"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemReader = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importStar(require("fs"));
const glob_1 = require("glob");
const os_1 = require("os");
const path_1 = tslib_1.__importStar(require("path"));
const util_1 = require("util");
const recursive_readdir_1 = tslib_1.__importDefault(require("recursive-readdir"));
const get_folder_size_1 = tslib_1.__importDefault(require("get-folder-size"));
const FILE_NOT_FOUND_CODE = 'ENOENT';
class FileSystemReader {
    fileExists(filePath) {
        return fs_1.default.existsSync(filePath);
    }
    readFile(filePath) {
        try {
            return fs_1.default.readFileSync(filePath, 'utf8');
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async readFileAsync(filePath) {
        const read = (0, util_1.promisify)(fs_1.default.readFile);
        try {
            return await read(filePath, 'utf8');
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async recursiveReadDir(rootDir, ignores) {
        const ignoreDirs = ignores === null || ignores === void 0 ? void 0 : ignores.map((ignore) => {
            if (typeof ignore === 'string' && !path_1.default.extname(ignore)) {
                return (dir, stats) => stats.isDirectory() && path_1.default.basename(dir) === path_1.default.basename(ignore);
            }
            return ignore;
        });
        if (!(0, fs_1.existsSync)((0, path_1.resolve)(rootDir)) || !(0, fs_1.statSync)((0, path_1.resolve)(rootDir)).isDirectory()) {
            return [];
        }
        return (0, recursive_readdir_1.default)(rootDir, ignoreDirs);
    }
    async readGlob(glob) {
        return new Promise((resolve, reject) => {
            new glob_1.Glob(glob, {}, (err, matches) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(matches);
                }
            });
        });
    }
    hasGlobSpecialChars(pattern) {
        return (0, glob_1.hasMagic)(pattern);
    }
    readBinaryFile(filePath) {
        try {
            return fs_1.default.readFileSync(filePath);
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    async readBinaryFileAsync(filePath) {
        const read = (0, util_1.promisify)(fs_1.default.readFile);
        try {
            return await read(filePath);
        }
        catch (error) {
            return this.handleFileError(error);
        }
    }
    getHomeDirectory() {
        return (0, os_1.homedir)();
    }
    bytesToMb(size) {
        if (!size) {
            return '0 MB';
        }
        return (size / 1024 / 1024).toFixed(2) + ' MB';
    }
    getSize(filePath) {
        try {
            return fs_1.default.statSync(filePath).size;
        }
        catch (_a) {
            return undefined;
        }
    }
    async getFolderSizeAsync(directory) {
        return new Promise((resolve) => {
            (0, get_folder_size_1.default)(directory, (err, size) => {
                if (err) {
                    resolve(undefined);
                }
                return resolve(size);
            });
        });
    }
    handleFileError(error) {
        if (error && error.code === FILE_NOT_FOUND_CODE) {
            return undefined;
        }
        else {
            throw error;
        }
    }
}
exports.FileSystemReader = FileSystemReader;
