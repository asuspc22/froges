"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = exports.capitalise = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
const case_1 = require("case");
const log_symbols_1 = tslib_1.__importDefault(require("./log-symbols"));
const log_color_1 = require("./log-color");
const graphql_types_1 = require("../graphql/graphql-types");
const environment_1 = require("../shared/environment");
const ctrlC = 'Press Ctrl+C to cancel.';
const gettingStartedDACLink = 'https://go.atlassian.com/dac/platform/forge/getting-started/#log-in-with-an-atlassian-api-token';
const encryptedValue = '****';
const greenTick = `${chalk_1.default.bold(chalk_1.default.green('✔'))}`;
const buildTerminalLink = (text) => (0, terminal_link_1.default)(chalk_1.default.bold(text), text, { fallback: () => chalk_1.default.underline.bold(text) });
const autoSpaceSentences = (...sentences) => sentences
    .filter((sentence) => sentence.length > 0)
    .join(' ');
const fatalError = (message) => chalk_1.default.bold(chalk_1.default.red(message));
const keytarAccessErrorBase = (message) => `Keytar error detected: ${message}`;
const capitalise = (word) => word.charAt(0).toUpperCase() + word.slice(1);
exports.capitalise = capitalise;
const getLintMessage = (line, column, message, level, colourFunction, reference) => `${chalk_1.default.dim(`${line}:${column}`.padEnd(7))} ${colourFunction(level.padEnd(8))} ${message}  ${chalk_1.default.dim(reference)}\n`;
const checkLintTotalPlurals = (numErrors, numWarnings, numFixableErrors, numFixableWarnings) => ({
    pluralCheckedErrors: `${numErrors} ${numErrors === 1 ? 'error' : 'errors'}`,
    pluralCheckedWarnings: `${numWarnings} ${numWarnings === 1 ? 'warning' : 'warnings'}`,
    pluralCheckedTotal: `${numErrors + numWarnings} ${numErrors + numWarnings === 1 ? 'issue' : 'issues'}`,
    pluralCheckedFixableErrors: `${numFixableErrors} ${numFixableErrors === 1 ? 'error' : 'errors'}`,
    pluralCheckedFixableWarnings: `${numFixableWarnings} ${numFixableWarnings === 1 ? 'warning' : 'warnings'}`
});
const platformKeytarRecommendations = () => {
    switch (process.platform) {
        case 'darwin':
            return 'Ensure you enable access to the macOS keychain when prompted.';
        case 'linux':
            return `Ensure you have ${chalk_1.default.bold('libsecret')} installed.`;
        default:
            return '';
    }
};
exports.Text = {
    error: {
        noKeytar: autoSpaceSentences(`The CLI couldn't securely store your login credentials in a local keychain.`, platformKeytarRecommendations(), `If a local keychain is not available, use environment variables before trying again. See ${buildTerminalLink(gettingStartedDACLink)} for more.`),
        noTokenStored: `Not logged in. If a local keychain is available, run ${chalk_1.default.bold('forge login')}, otherwise set environment variables before trying again. See ${buildTerminalLink(gettingStartedDACLink)} for more.`,
        keytarAccessError: {
            other: (message) => keytarAccessErrorBase(message),
            mac: (message) => keytarAccessErrorBase(message) +
                `\nSomething went wrong while accessing Keychain Access. Try locking and unlocking the login keychain.`,
            linux: (message) => keytarAccessErrorBase(message) + `\nSomething went wrong while accessing Secret Service API.`,
            windows: (message) => keytarAccessErrorBase(message) + `\nSomething went wrong while accessing Credentials Vault.`
        },
        outdatedCLIVersion: (installed, latest) => `Warning: Your version of Forge CLI is out of date. We recommend you update to the latest version to get the latest features and bug fixes.` +
            `\nRun ${chalk_1.default.bold(`npm uninstall -g @forge/cli`)} followed by ${chalk_1.default.bold(`npm install -g @forge/cli`)} to update from version ${chalk_1.default.bold(installed)} to ${chalk_1.default.bold(latest)}.` +
            `\n`,
        outdatedNodeVersion: (compatibleNodeVersion, currentNodeVersion) => fatalError(`Unsupported Node.js version. The CLI requires Node.js ${compatibleNodeVersion}, but you're using Node.js ${currentNodeVersion}.`),
        invalidProduct: 'Invalid product. Rerun the command with a valid product.',
        invalidSite: 'The site you entered is not an Atlassian site. Rerun the command with the URL to an Atlassian site to install the app.',
        invalidTokenInKeytar: `Your API token is no longer valid. Run ${chalk_1.default.bold('forge login')} to reset your login credentials.`,
        invalidTokenInEnv: (instructionsUrl, emailVar, tokenVar) => `The API token on your machine is no longer valid.` +
            `\n    1) Get a new API token: ${instructionsUrl}` +
            `\n    2) Set your email and the token to ${emailVar} and ${tokenVar} environment variables.`,
        promptInputRequired: 'Your response is needed to continue.',
        noExecutableFile: "Couldn't find the main executable file",
        unhandledRejection: (reason, promise) => `Error at ${promise}, reason: ${reason}`,
        resourceDefinitionMissing: (resourceKeys) => `The following resources are declared but are improperly defined in the manifest.yml file:\n - ${resourceKeys.join('\n - ')}`,
        resourceDirectoryMissing: (resourceKey, directory) => `Resource ${resourceKey} at: ${directory} not found`,
        resourceDirectoryEmpty: (resourceKey, directory) => `Resource ${resourceKey} at: ${directory} is an empty directory`,
        templateFetchFailed: 'Failed to fetch templates, try running the command again.',
        handlerFormat: (handler) => `Function handler "${handler}" must be in format <module>.<function>, example: index.run`
    },
    warning: {
        plaintextCredentialsFound: (url) => `Your credentials were stored in plaintext by a previous version of the Forge CLI. For additional security, revoke your existing API token by visting this URL ${buildTerminalLink(url)}.`,
        plaintextCredentialsMigrated: 'The credentials found in plaintext have been migrated to your local keychain.',
        plaintextCredentialsNotMigrated: autoSpaceSentences(`The CLI couldn't securely store your login credentials in a local keychain.`, platformKeytarRecommendations(), `If a local keychain is not available, use environment variables instead. See ${buildTerminalLink(gettingStartedDACLink)} for more information.`),
        unsupportedNodeVersion: (_userNodeVersion, supportedNodeVersions) => log_color_1.LogColor.warn(`Warning: Forge CLI supports Node.js ${supportedNodeVersions}.` +
            `\nUnsupported Node.js versions are not guaranteed to work correctly.\n`)
    },
    installationContext: {
        overviewProduct: 'Select the product your app uses.\n',
        promptProduct: 'Select a product:',
        overviewSite: '\nEnter your site. For example, your-domain.atlassian.net\n',
        promptSite: 'Enter the site URL:',
        promptWorkspace: 'Enter the workspace URL:'
    },
    upgradeContext: {
        overview: `To upgrade your app to use the latest scopes, select it from the list.\n${ctrlC}`,
        promptInstallation: 'Select the site to upgrade:'
    },
    optionSite: 'site URL (example.atlassian.net)',
    optionProduct: (supportedProducts) => `product (${supportedProducts.join(', ')})`,
    optionVerbose: 'enable verbose mode',
    optionJson: 'output results in JSON format',
    invalidCmd: (command) => `’${command}’ is not a Forge command.`,
    invalidCmdHelp: `Run ${chalk_1.default.bold('forge --help')} to see the full list of available commands.`,
    rerunningWithVerbose: 'Rerunning the command with --verbose may give more details.',
    ctrlC,
    graphQL: {
        request: (url, query, variables) => `▶️  GraphQL ${url}\nQuery: ${query}\nVariables: ${variables}`,
        response: (result, requestId) => `◀️  GraphQL\nRequest ID: ${requestId || 'unknown'}\nResult: ${result}`,
        error: 'Server error',
        outdatedClientVersion: `Your version of Forge CLI is no longer supported.` +
            `\nRun ${chalk_1.default.bold(`npm uninstall -g @forge/cli`)} followed by ${chalk_1.default.bold(`npm install -g @forge/cli`)} to update to the latest version.` +
            `\n`
    },
    snapshot: {
        error: (errorCode, errorMessage) => `Error thrown in the snapshot context.\n${errorCode}: ${errorMessage}\nLearn more about the snapshot context at https://go.atlassian.com/forge-snapshot-context.`,
        timeout: `A timeout error occurred in the snapshot context.\nLearn more about the snapshot context at https://go.atlassian.com/forge-snapshot-context.`
    },
    hostedResources: {
        error: (errorMessage) => `Failed to deploy hosted resources. ${errorMessage}`,
        missingEntrypoint: `Missing index.html for custom UI resource. Make sure the file paths for resources in the manifest.yml file are correct and contain an index.html file.`,
        missingEntrypointWithResourceDetails: (resourceKey, directory) => `Missing index.html file for ${resourceKey}. Make sure the resource directory (${directory}) is correct and contains an index.html file.`,
        malformedEntrypoint: `Invalid index.html file. Make sure the index.html file has the <html> root element.`,
        malformedEntrypointWithKey: (resourceKey) => `Invalid index.html file for ${resourceKey}. Make sure the index.html file has the <html> root element.`,
        lambdaTimeout: 'Reduce the number or size of the files you’re uploading to avoid a timeout.'
    },
    bundle: {
        detectedChanges: 'Reloading code...',
        errors: (errors) => `Bundling failed: ${errors.join(', ')}`,
        failed: 'Bundling failed.',
        finished: 'Bundling succeeded.',
        warnings: (warnings) => `Bundling warnings: ${warnings.join(', ')}`
    },
    config: {
        missing: `Your app details are missing from the manifest.yml file. Register your app by running ${chalk_1.default.bold('forge register')}.`,
        invalid: `Invalid app details in the manifest.yml file. Register your app by running ${chalk_1.default.bold('forge register')}.`,
        manifest: {
            invalid: 'Command failed due to validation error.'
        }
    },
    autocomplete: {
        cmd: {
            desc: 'configures autocomplete for the Forge CLI'
        },
        confirmInstalling: "This appends a line to your shell's config file. Would you like to continue?",
        installing: 'Installing autocomplete. Restart your shell when installation is completed.',
        uninstalling: 'Uninstalling autocomplete.',
        postinstall: `\n${chalk_1.default.cyan('ℹ')} To install autocompletion for Forge, run 'forge autocomplete install'.\n`,
        error: {
            badArg: (arg) => `${arg ? `Invalid argument detected: "${arg}"` : 'Missing argument'}. Expected: "install" or "uninstall".`,
            unsupportedShell: 'Unsupported shell detected. Autocomplete functionality is only available on bash, fish, and zsh shells.',
            unsupportedNodeVersion: 'Your NodeJS version does not support Forge autocompletion. You must upgrade to NodeJS LTS version 12.7.0 or later.'
        }
    },
    login: {
        cmd: 'log in to your Atlassian account',
        optionEmail: 'specify the email to use',
        optionToken: 'specify the API token to use',
        introText: 'Log in to your Atlassian account',
        promptEmail: 'Enter your email:',
        url: (link) => `Next, enter your Atlassian API token. If you don't have a token, visit this URL to create one:\n${buildTerminalLink(link)}`,
        promptToken: 'Enter your Atlassian API token:',
        checking: 'Logging you in...',
        nextStep: `Now try ${chalk_1.default.bold('forge create')} to start a new app.`,
        success: (name) => `Logged in as ${name}.`,
        error: "We couldn't log you in with those credentials. Check your email address and token before rerunning the command."
    },
    logout: {
        cmd: 'log out of your Atlassian account',
        loggedOut: `${greenTick} Logged out.`
    },
    whoami: {
        cmd: 'display the account information of the logged in user',
        success: {
            containerToken: (ciTokenKey) => `Logged in with CI Token ${ciTokenKey}`,
            personalCredentials: (email, name, accountId) => `Logged in as ${name} (${email})\nAccount ID: ${accountId}`
        },
        error: {
            personalCredentialsEnv: (emailKey, apiTokenKey) => `We couldn't get your Atlassian account information. Check the ${emailKey} and ${apiTokenKey} environment variables.`,
            personalCredentialsKeytar: `We couldn't get your Atlassian account information. You may need to run ${chalk_1.default.bold('forge login')} to log in again.`
        }
    },
    feedback: {
        cmd: 'feedback',
        description: 'let us know what you think about Forge',
        success: 'Thank you for using Forge',
        action: {
            start: `Help us make Forge even better.

For any questions, post them on: https://go.atlassian.com/developer-community

To report bugs or issues, go to: https://go.atlassian.com/forge-project

What do you like or don't like about Forge? Share your feedback below or press Ctrl+C to cancel.
`,
            enterFeedbackPrompt: 'Enter your feedback:',
            sendingFeedbackProgress: 'Sending your feedback...',
            error: 'We were unable to send your feedback. Please visit https://community.developer.atlassian.com.',
            success: 'Feedback sent.'
        }
    },
    create: {
        cmd: {
            desc: 'create an app',
            start: 'Creating app...',
            success: (appName) => `Created ${appName}`,
            successDetails: (directory, validEnvironmentOptions) => `\nYour app is ready to work on, deploy, and install. We created ${validEnvironmentOptions.length} environments you can deploy to: ${validEnvironmentOptions
                .map(environment_1.environmentToOption)
                .join(', ')}.\n\nChange to directory ${chalk_1.default.bold(directory)} to see your app files.`
        },
        intro: (givenDirectory) => `Creating an app in directory ${chalk_1.default.bold(givenDirectory)}.\n`,
        introWithCurrentDirectory: (currentDirectory) => `Creating an app in your current directory:\n\n    ${chalk_1.default.bold(currentDirectory)}\n`,
        optionTemplate: 'specify the template to use',
        optionDirectory: 'specify the directory to create (uses the template name by default)',
        overviewAppName: `\nName your app. The app name can include dashes, spaces, and underscores.\n`,
        overviewTemplates: '\nStart with a template. Each template contains the required files to be a valid app.\n',
        waitTemplates: 'Getting template list...',
        promptName: 'Enter a name for your app:',
        promptCategory: 'Select a category:',
        promptTemplate: 'Select a template:',
        taskTemplate: {
            title: 'Downloading template',
            downloading: (template) => `Downloading ${template} template project...`,
            extracting: 'Extracting template'
        },
        taskRegister: 'Registering app',
        taskCreateEnvironments: 'Creating environments',
        taskPackages: 'Installing dependencies',
        error: {
            dirtyDirectory: 'Destination directory is not empty',
            app: {
                creation: "Your app couldn't be created. Try again."
            },
            directory: {
                exists: (path) => `The directory ${path} already exists. Run ${chalk_1.default.bold('forge create')} using a different app name.`
            },
            name: {
                tooLong: () => `The app name exceeds 50 characters. Run ${chalk_1.default.bold('forge create')} using a shorter app name.`
            },
            template: {
                download: (template) => `Failed to download the ${template} template. Run ${chalk_1.default.bold('forge create')} again.`,
                notFound: (template) => `The template ${template} doesn't exist. Run ${chalk_1.default.bold('forge create')} using a different template.`,
                noTemplates: 'There are no templates to choose from.',
                unexpectedArchiveFormat: 'Unexpected template format.'
            },
            packages: {
                installFail: `Something went wrong while installing app dependencies. Try running ${chalk_1.default.bold('forge create')} again.'
        )} to try again.`
            }
        }
    },
    register: {
        intro: 'Registering the app to you.',
        cmd: {
            desc: "register an app you didn't create so you can run commands for it",
            start: `Registering app...`,
            success: (appName) => `Registered ${appName}`,
            successDetails: (validEnvironmentOptions) => `\nYour app is ready to work on, deploy, and install. We created ${validEnvironmentOptions.length} environments you can deploy to: ${validEnvironmentOptions
                .map(environment_1.environmentToOption)
                .join(', ')}.\n\nUse ${chalk_1.default.bold('forge deploy')} to deploy your app to an environment.`
        },
        confirmQuestion: 'Are you sure you want to overwrite the existing app details?'
    },
    env: {
        option: 'specify the environment (defaults to your development environment)',
        invalid: 'Invalid environment name',
        developmentOnly: (envKey) => `${(0, environment_1.environmentToOption)(envKey)} cannot be set as default environment. Only development environments can be used.`,
        error: {
            appOwnerNotExist: 'Missing app owner details',
            appNotExist: `Your app could not be found. Make sure the app details in the manifest.yml file are correct before trying again.`,
            envNotExist: (envKey) => `Environment ${chalk_1.default.bold((0, environment_1.environmentToOption)(envKey))} does not exist. Check the environment name and try again.`
        },
        displayEnvironment: (envKey, envType) => {
            if (envType === graphql_types_1.AppEnvironmentType.Development &&
                envKey !== environment_1.DEFAULT_ENVIRONMENT_KEY &&
                envKey !== environment_1.DEFAULT_ENVIRONMENT_OPTION) {
                return `${chalk_1.default.gray('DEV')} ${(0, environment_1.environmentToOption)(envKey)}`;
            }
            return (0, environment_1.environmentToOption)(envKey);
        },
        warn: {
            envWillBeCreated: (envKey) => `${chalk_1.default.bold('Warning:')} Environment ${chalk_1.default.bold((0, environment_1.environmentToOption)(envKey))} does not exist. If you continue, this development environment will be created for you.`
        },
        confirm: 'Do you want to continue?'
    },
    defaultEnv: {
        info: 'You do not currently have a default development environment set. A default development environment is required to run commands without specifying an environment.',
        prompt: 'Enter a name for your default development environment:',
        warn: `${chalk_1.default.bold('Warning:')} A development environment with this name already exists. If you continue, you may be using the same environment as another contributor.`,
        confirm: 'Do you want to continue?',
        setSuccess: (envKey, envType) => `${exports.Text.env.displayEnvironment(envKey, envType)} has been set as your default development environment`,
        createAndSetSuccess: (envKey, envType) => `${exports.Text.env.displayEnvironment(envKey, envType)} has been created and set as your default development environment`,
        settingsInfo: `You can change your default development environment later by running ${chalk_1.default.bold('forge settings set')}.`
    },
    varsSet: {
        cmd: {
            desc: 'set an environment variable',
            start: 'Setting environment variable...',
            success: 'Environment variable set.'
        },
        overview: (environment, environmentType) => `Setting the value of a variable in the ${exports.Text.env.displayEnvironment(environment, environmentType)} environment.`,
        encryptInfo: 'Encrypting a variable means that the value will not be shown in the terminal.',
        promptEncrypt: `Select if you want the value encrypted:`,
        keyInfo: 'Use a new key to create a variable, or use an existing key to override a variable.',
        promptKey: 'Enter the variable key:',
        promptValue: 'Enter the variable value:',
        optionSecret: 'encrypt variable',
        yes: 'Yes',
        no: 'No'
    },
    varsUnset: {
        cmd: {
            desc: 'remove an environment variable',
            start: (environment, envType) => `Unsetting the variable in the ${exports.Text.env.displayEnvironment(environment, envType)} environment.`,
            success: (key) => `\n${greenTick} ${key} variable removed.`
        }
    },
    varsList: {
        hint: `\nRun ${chalk_1.default.bold('forge variables list')} to see your environment variables.\n`,
        cmd: 'list the environment variables',
        empty: (environment, envType) => `There are no variables in the ${exports.Text.env.displayEnvironment(environment, envType)} environment.\n\nUse ${chalk_1.default.bold('forge variables set')} to create a variable.\n`,
        encryptedValue,
        overview: (environment, envType) => `Showing variables from the ${exports.Text.env.displayEnvironment(environment, envType)} environment:\n`,
        postfix: `\nNote, the values of encrypted variables are shown as ${encryptedValue}.\n`
    },
    providers: {
        desc: 'manage external providers'
    },
    configureProvider: {
        cmd: {
            desc: 'configure provider credentials',
            start: 'Configuring provider credentials...',
            success: 'oauth provider credentials configuration is finished.'
        },
        overview: (environment) => `Configuring provider in the ${(0, environment_1.environmentToOption)(environment)} environment.`,
        providerKeyInfo: 'Use a provider key from the list for configuration.',
        noProviders: "Count't find providers in the manifest file. Add one.",
        promptProviderKey: 'Select provider to configure:',
        optionClientSecret: 'client secret',
        promptClientSecret: 'Enter the client secret:'
    },
    environment: {
        desc: 'manage app environments'
    },
    createEnvironment: {
        cmd: {
            desc: 'create a new development environment',
            start: 'Creating environment...',
            success: (envKey, envType) => `Created ${exports.Text.env.displayEnvironment(envKey, envType)}`
        },
        overview: 'Create a new development environment.',
        promptEnvironmentKey: 'Enter a name for your environment:',
        successMessage: 'You can now tunnel or deploy to this new development environment.',
        optionEnvironmentKey: 'specify a name for the environment'
    },
    listEnvironment: {
        cmd: {
            desc: 'view all environments for this app'
        },
        overview: 'Showing all environments of the app:\n'
    },
    deleteEnvironment: {
        cmd: {
            desc: 'delete an existing development environment',
            start: 'Deleting environment(s)...'
        },
        overview: 'Delete an existing development environment.',
        info: 'Environments with existing installations cannot be deleted.\n',
        prompt: 'Select development environment:',
        confirmationInfo: 'You are deleting the following environment(s):',
        promptConfirmation: 'Do you want to continue?',
        individualSuccessMessage: (envKey, envType) => `${log_symbols_1.default.info} ${exports.Text.env.displayEnvironment(envKey, envType)} deleted successfully.`,
        successMessage: 'Environment(s) deleted.',
        optionEnvironmentKey: 'specify the environment to delete',
        warningMessage: `${chalk_1.default.bold('Warning:')} When deleting a development environment, you may impact in progress deployments or tunnels.`,
        noEnvironmentMessage: 'There are no development environments to delete.',
        hasInstallationError: (envKey) => `${(0, environment_1.environmentToOption)(envKey)} cannot be deleted because the environment is installed on a site. You can show all the current installations of your app by running ${chalk_1.default.bold('forge install list')}.`
    },
    storage: {
        cmd: {
            desc: 'manage storage for your app'
        }
    },
    entitiesIndexes: {
        cmd: {
            desc: 'manage indexes for custom entities present in your app'
        }
    },
    entitiesIndexesList: {
        cmd: {
            desc: 'List indexes for all custom entities present in your app'
        },
        missingEntities: 'No entities were declared in manifest'
    },
    contributors: {
        desc: 'manage who has access to your app'
    },
    addContributor: {
        cmd: {
            desc: 'add a new contributor to your app',
            start: 'Adding contributor to your app',
            success: 'If an Atlassian account is associated with this email address, they can now access your app.'
        },
        overview: 'Adding a new contributor to your app',
        optionSkipConfirmation: 'skip confirmation of email before adding a new contributor to the app',
        optionContributorEmail: 'email address associated with Atlassian account (your-name@your-domain.com)',
        contributorEmailInfo: "Enter the email address associated with the contributor's Atlassian account. For example, your-name@your-domain.com",
        promptContributorEmail: 'Enter their email:',
        confirmationInfo: 'This contributor will have full access to your app via the CLI and developer console.',
        learnMore: 'To learn more about access and permissions, go to: https://go.atlassian.com/contributor-permissions',
        promptConfirmation: 'Do you want to continue?'
    },
    listContributors: {
        cmd: {
            desc: 'list all contributors for your app'
        },
        banner: '\nShowing all current contributors for your app:',
        noContributors: 'No users have been assigned contributor status for your app',
        appOwner: `${chalk_1.default.bold('(App owner)')}`,
        userInactive: '(Deactivated)',
        missingAppContributors: `Cannot list contributors for the app: something went wrong with fetching app contributors.`
    },
    removeContributors: {
        cmd: {
            desc: 'remove contributors from your app',
            start: 'Removing contributor(s) from your app...',
            success: 'Contributor(s) removed successfully'
        },
        overview: 'To remove a contributor from your app, select them from the list.\nPress Ctrl+C to cancel.',
        optionSkipConfirmation: 'skip confirmation before removing contributors from the app',
        optionContributorEmail: 'email address associated with Atlassian account (your-name@your-domain.com)',
        promptContributorEmail: 'Select contributor(s) to remove from the app',
        confirmationInfo: 'You are removing the following contributor(s). They will no longer have access to your app via the CLI and developer console:',
        promptConfirmation: 'Do you want to continue?',
        commandSuccessMessage: (name) => `${chalk_1.default.bold(name.join(', '))} can no longer access your app.`,
        addContributorMessage: "There are no contributors for this app. To add a contributor, run the 'contributors add' command."
    },
    artifact: {
        error: {
            noDeployUrl: "Couldn't find deployment URL",
            noPresignedUrls: "Couldn't find presigned URLs",
            noUploadId: "Couldn't find uploadId",
            noManifestInZip: (manifestFilename) => `Couldn't find ${manifestFilename} file in the zip archive. Add one.`,
            noManifestAtPath: (path) => `We couldn't find the artifact file ${path}.`,
            empty: 'The provided artifact file was empty.',
            invalidYaml: (manifestFilename) => `The ${manifestFilename} file is not a valid YAML. Fix it and try again.`
        }
    },
    upload: {
        error: {
            notFound: (path) => `Couldn't find the file: ${path}`,
            empty: (path) => `File ${path} appears to be empty.`,
            status: (status, responseBody) => `Upload failed with status ${status} and body:\n${responseBody}`
        }
    },
    deploy: {
        cmd: {
            desc: 'deploy your app to an environment',
            start1: (envKey, envType) => `Deploying your app to the ${exports.Text.env.displayEnvironment(envKey, envType)} environment.\n${ctrlC}\n`,
            start2: (appName, envKey, envType) => `Deploying ${appName} to ${exports.Text.env.displayEnvironment(envKey, envType)}...`,
            success: 'Deployed\n',
            successDetails: (appName, envKey, envType) => `Deployed ${appName} to the ${exports.Text.env.displayEnvironment(envKey, envType)} environment.`,
            distributePageLink: (appId) => `To install on a site that you're an admin of, run ${chalk_1.default.bold('forge install')}.\n` +
                'To install on any other site, generate an installation link in the developer console and share it with the site admin: ' +
                `https://developer.atlassian.com/console/myapps/${appId}/distribution`
        },
        taskLint: {
            lintError: log_color_1.LogColor.error(`Error: The deploy failed due to errors in the app code. Fix the errors before rerunning forge deploy, or run ${chalk_1.default.bold('forge deploy --no-verify')} to skip the linter.\n`),
            lintWarning: (numWarnings) => {
                const { pluralCheckedTotal } = checkLintTotalPlurals(0, numWarnings, 0, 0);
                return log_color_1.LogColor.warn(`${pluralCheckedTotal} found. Run ${chalk_1.default.bold('forge lint')} to review the warnings.`);
            }
        },
        taskListInstallation: {
            listInstallationError: log_color_1.LogColor.error(`Error: The deployment failed due to errors while trying to list app installations.`)
        },
        connectKeyChange: {
            continueChange: `Do you wish to continue with changing the Connect key?`,
            continueDelete: `Do you wish to contine with deleting the Connect key?`,
            mpacAppConnectKeyChangeAnalyticsError: 'Cannot change app.connect.key for an app with an Atlassian Marketplace listing.',
            mpacAppConnectKeyChangeError: (mpacAppKey, connectKey) => log_color_1.LogColor.error(`Cannot change the app.connect.key from \'${mpacAppKey}\' to \'${connectKey}\'. The app's Connect key must match the Atlassian Marketplace key.\n`),
            connectKeyChangeWarning: (environment, migrationKey, connectKey) => `WARNING: Changing the app.connect.key in ${environment} from \'${migrationKey}\' to \'${connectKey}\' affects features using the Connect key as an identifier. ` +
                `\nLearn more about the impact of this change at https://go.atlassian.com/forge-connect-key-changes.\n`,
            connectKeyDeleteWarning: (environment) => `WARNING: You're about to delete the app.connect.key of the app in ${environment}. ` +
                `\nIf you proceed, non-Forge Connect installations using the Connect key will no longer be replaced by future Forge installations of the app, and will co-exist. ` +
                `\nLearn more at https://go.atlassian.com/forge-connect-key-deletion.\n`
        },
        taskPackage: {
            title: 'Packaging app files',
            archiverWarning: (err) => `Packaging warning: ${err.message}`,
            packageBundledFiles: 'Packaging bundled files',
            packageFile: (fileName, filePath) => `File added to archive: ${filePath}` + fileName ? `, from ${fileName}` : '',
            archiveCreated: (archivePath) => `Archive created: ${archivePath}`
        },
        taskUpload: {
            title: 'Uploading app',
            uploadingArchive: (uploadUrl) => `Uploading archive to ${uploadUrl}...`,
            uploadingResources: () => 'Uploading resources'
        },
        taskDeploy: {
            serverStepStarted: (name) => name,
            serverStepFailed: 'Deployment failed'
        },
        error: {
            notFound: "Couldn't find app deployment"
        },
        outdatedInstallations: `We've detected new scopes or egress URLs in your app.\n` +
            `Run ${chalk_1.default.bold('forge install --upgrade')} and restart your tunnel to put them into effect.`,
        listIndexes: (environment) => {
            const indexCommand = chalk_1.default.bold(`forge storage entities indexes list -e ${(0, environment_1.environmentToOption)(environment)}`);
            return (`Run ${indexCommand} to check the status of the indexes.`);
        },
        reindexingInProgress: {
            continueDeployment: 'Reindexing is currently in progress. Are you sure you want to deploy?',
            successfulDeployment: 'Deployment successful. Please note - indexing currently in progress.'
        },
        egressURL: {
            invalidURLError: (cause) => {
                const urls = cause
                    .replace(/^Invalid.*object: /, '')
                    .split(', ')
                    .filter(Boolean)
                    .map((url) => `‘${url}’`);
                let plurality = '';
                let message;
                switch (urls.length) {
                    case 0:
                        message = '';
                        break;
                    case 1:
                        message = urls[0];
                        break;
                    case 2:
                        plurality = 's';
                        message = `${urls[0]} and ${urls[1]}`;
                        break;
                    default:
                        const lastElem = urls.pop();
                        plurality = 's';
                        message = `${urls.join(', ')}, and ${lastElem}`;
                        break;
                }
                return `Invalid URL${plurality} detected for the egress permissions object${plurality} ${message}\nLearn more at https://go.atlassian.com/forge-content-security-and-egress-controls`;
            },
            tooManyURLCharactersError: (cause) => {
                const urlMaxLength = cause.replace(/[^0-9]/g, '');
                return `An egress permission URL exceeds ${urlMaxLength} characters.`;
            },
            tooManyUrlsError: (cause) => {
                const arr = cause
                    .replace(/[^0-9 ]/g, '')
                    .replace(/  +/g, ' ')
                    .split(' ');
                return `There are ${arr[0]} egress permission URLs provided, exceeding the maximum of ${arr[1]}.`;
            }
        }
    },
    install: {
        cmd: {
            description: 'manage app installations',
            start: (envKey, envType) => `Installing your app on to ${exports.Text.env.displayEnvironment(envKey, envType)}...`,
            end: (displayTick) => `${displayTick ? greenTick + ' ' : ''}Install complete!`
        },
        booleanToScope: (isLatest) => (isLatest ? `Latest` : `Out-of-date`),
        banner: `\nInstalling your app onto an Atlassian site.\n${ctrlC}\n`,
        optionConfirmScopes: 'skip confirmation of scopes for the app before installing or upgrading the app',
        optionUpgrade: 'upgrade an existing installation',
        listScopes: (scopes) => `Your app will be installed with the following scopes:\n${scopes
            .map(({ name, requiresInteractiveConsent }) => `- ${name}${requiresInteractiveConsent ? ' (requires user consent)' : ''}`)
            .join('\n')}\n`,
        listEgressAddresses: (egressAddresses) => `Your app will exchange data with the following urls:\n${egressAddresses.map((url) => `- ${url}`).join('\n')}\n`,
        permissionMismatchCommandSuggestion: (environment) => `forge deploy -e ${(0, environment_1.environmentToOption)(environment)}`,
        permissionsMismatch: (environment) => `The scopes or egress URLs in the manifest are different from the scopes in your most recent deployment to ${(0, environment_1.environmentToOption)(environment)}. Try running ${chalk_1.default.bold(exports.Text.install.permissionMismatchCommandSuggestion(environment))} before installing.\n`,
        multiProductScopesDetected: (productsToInstall, productsToUpgrade, site, environment) => `\nWe detected your app requires scopes across multiple products.\nRun ${chalk_1.default.bold('forge install')} for each of the following:\n${productsToUpgrade
            .map((product) => `- forge install --upgrade -p ${(0, case_1.capital)(product)} -s ${site} -e ${(0, environment_1.environmentToOption)(environment)}`)
            .join('\n')}${productsToUpgrade.length !== 0 && productsToInstall.length !== 0 ? '\n' : ''}${productsToInstall
            .map((product) => `- forge install -p ${(0, case_1.capital)(product)} -s ${site} -e ${(0, environment_1.environmentToOption)(environment)}`)
            .join('\n')}`,
        promptForPermissionsConfirmation: (permissionsMismatchInDevelopment) => permissionsMismatchInDevelopment
            ? 'Are you sure you want to continue installing the app?'
            : 'Do you want to continue?',
        success: {
            banner: (envKey, envType, product, site) => `Your app in the ${exports.Text.env.displayEnvironment(envKey, envType)} environment is now installed in ${product} on ${buildTerminalLink(site)}`
        },
        error: {
            invalidAtlassianSite: (url) => `The URL you entered doesn't belong to an Atlassian site: ` +
                `\n${url.toString()} ` +
                `\n\nRun the command using a different URL.`,
            invalidWorkspace: (url) => `The URL you entered is not a valid workspace: ` +
                `\n${url.toString()} ` +
                `\n\nRun the command using a different URL.`,
            url: (url) => `Site URL is invalid: ${url}`,
            site: (url) => `Site is invalid: ${url}`,
            alreadyInstalledError: `Installation error: App is already installed.\nIf you're trying to upgrade your app, use the ${chalk_1.default.bold('forge install --upgrade')} command.`,
            serverSideInstallationError: (message) => `Installation error: ${message}`,
            noDeploymentFound: (environment) => `Forge apps must be deployed before installation. Deploy your app by running ${chalk_1.default.bold(`forge deploy -e ${(0, environment_1.environmentToOption)(environment)}`)}.`,
            permissionsDeniedInstructions: (requestId, appId) => `Insufficient permissions to install app (requestId: ${requestId})` +
                '\n\nTo install the app on this site, generate an installation link ' +
                'in the developer console and share it with the site admin: ' +
                `https://developer.atlassian.com/console/myapps/${appId}/distribution`
        },
        security: {
            banner: (site) => `\n${chalk_1.default.gray('=== ')}Security questions\n
Forge apps installed on ${site} must comply with our corporate security guidelines.
Read the guidelines on the page below before answering the required security questions:
${buildTerminalLink('https://hello.atlassian.net/wiki/x/iIC1Hg')}\n`,
            questions: [
                'Does the app store, process, or transmit any Personal Data?',
                'Does the app acquire, store, or process credit card and/or payment information?',
                'Does the app store or transmit any data beyond the Atlassian cloud (for example, through API calls to external products or services)?',
                'Does the app make administrative changes to Atlassian products or services?'
            ],
            notTrustedApp: {
                warn: (site) => `\nYou answered ${chalk_1.default.bold('yes')} to one or more of the questions. Corporate security needs to review your app before you install it on ${site}.\n`,
                confirmApproval: `Has corporate security approved your app?`,
                corpSecurityHelpdesk: `\nCreate a legal ticket to request an app review here:\n
${buildTerminalLink('https://jira.sec.internal.atlassian.com/servicedesk/customer/portal/8/create/88')}

When corporate security has approved the app, you can proceed with the installation.\n`
            }
        },
        authorization: {
            banner: `\n${chalk_1.default.gray('=== ')}Authorize your app\n`,
            link: (link) => `Follow the prompts at this URL to authorize your app:
${buildTerminalLink(link)}\n`,
            openBrowser: `Press any key to open the URL in your default browser.`
        }
    },
    upgrade: {
        banner: `\nUpgrading your app on the Atlassian site.\n`,
        cmd: {
            start: (envKey, envType) => `Upgrading your app in ${exports.Text.env.displayEnvironment(envKey, envType)}...`,
            end: (displayTick) => `${displayTick ? greenTick + ' ' : ''}Upgrade complete!`,
            error: `Upgrade failed`
        },
        listScopes: (scopes) => `Your app will be upgraded with the following additional scopes:\n${scopes
            .map(({ name, requiresInteractiveConsent }) => `- ${name}${requiresInteractiveConsent ? ' (requires user consent)' : ''}`)
            .join('\n')}\n`,
        listEgressAddresses: (egressAddresses) => `Your app will exchange data with the following urls:\n${egressAddresses.map((url) => `- ${url}`).join('\n')}\n`,
        permissionsMismatch: (environment) => `The scopes or egress URLs in the manifest are different from the scopes in your most recent deployment to ${environment}. Try running ${chalk_1.default.bold(`forge deploy -e ${environment}`)} before upgrading.\n`,
        promptForPermissionsConfirmation: (permissionsMismatchInDevelopment) => permissionsMismatchInDevelopment
            ? 'Are you sure you want to continue upgrading the app?'
            : 'Do you want to continue?',
        success: {
            banner: (envKey, envType, product, site) => `Your app in the ${exports.Text.env.displayEnvironment(envKey, envType)} environment is now the latest in ${product} on ${buildTerminalLink(site)}.`
        },
        alreadyUpdated: {
            spinner: 'Site is already at the latest version',
            banner: (environment, product, site) => `\nYour app in the ${(0, environment_1.environmentToOption)(environment)} environment is at the latest in ${product} on ${buildTerminalLink(site)}.`
        },
        error: {
            serverSideInstallationError: (message) => `Upgrade error: ${message}`
        }
    },
    installList: {
        cmd: 'list app installations',
        banner: `\nShowing all the current installations of your app:`,
        noResourceId: 'Unknown site with no resource ID',
        noInstallations: `The app is not installed anywhere.\nRun ${chalk_1.default.bold('forge install')} to install your app on an Atlassian site.\n`
    },
    tunnel: {
        cmd: 'start a tunnel to connect your local code with the app running in the development environment',
        optionDebugger: 'enable debugger mode',
        preamble: 'Tunnel redirects requests you make to your local machine. This occurs for any Atlassian site where your app is installed in the specific development environment. You will not see requests from other users.',
        startingTunnel: (environmentKey, envType) => `Tunnelling to: ${exports.Text.env.displayEnvironment(environmentKey, envType)}`,
        startedServer: (port, isDebug) => `Listening for requests${isDebug ? ' on local port ' + port : ''}...`,
        startedTunnel: (tunnelUrl) => `Started tunnel at address: ${tunnelUrl}`,
        stoppingTunnel: 'Stopping tunnel...',
        stoppedTunnel: 'Tunnel stopped.',
        tunnelStatusChange: (status) => `Tunnel connection status changed: ${status}`,
        snapshotting: 'Snapshotting functions...',
        snapshottingNoLogs: 'No log output.',
        startedInspector: (serverAddress) => `Add "debugger;" statement to your app to pause.
Debugging in Google Chrome:
- Open Inspect page: chrome://inspect/
- Select "Open dedicated DevTools for Node"
- Open inspector URL: devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${serverAddress}
  `,
        inspectorUnsupported: `The ${chalk_1.default.bold('--debug')} flag is unsupported for your runtime.`,
        invoke: (requestId, handler) => `invocation: ${requestId} ${handler}`,
        invocationTimeout: (timeout) => `Function result will not be returned to the Forge platform, as the function did not complete within ${timeout} seconds. In invocations outside tunnel, functions that exceed the time limit are terminated.`,
        customUI: {
            fileServed: (filename, resourceKey) => `Serving file ${filename} for resource ${resourceKey}`,
            fileProxied: (filename, resourceKey, tunnelPort) => `Received proxy request. ${exports.Text.tunnel.customUI.fileServed(filename, resourceKey)} from specified address http://localhost:${tunnelPort}`,
            warning: {
                cspViolation: (localUrl, violation) => `CSP violation detected for '${violation}' while serving content at ${localUrl}\nFor an app to share data with external resources or use custom CSP, follow the steps in: https://go.atlassian.com/forge-content-security-and-egress-controls\n`
            }
        },
        pullDockerProgress: (percentCompleted) => `Checking Docker image... ${percentCompleted}%`,
        pullDockerSuccess: `Your Docker image is up to date.`,
        preBundleTask: (title) => `${log_color_1.LogColor.trace('===')} ${title}`,
        lintFailed: chalk_1.default.red(`${chalk_1.default.bold('Error:')} Linting failed due to errors in the app code.`),
        bundlingHeader: 'Bundling code...',
        bundlingSucceeded: 'App code bundled.',
        resourcesBundlingSucceeded: `${greenTick} Resources bundled.`,
        functionsBundlingSucceeded: `${greenTick} Functions bundled.`,
        error: {
            create: (message) => `Couldn't create tunnel, message: ${message}`,
            delete: (message) => `Couldn't delete tunnel, message: ${message}`,
            ngrok: `Failed to start tunnel, could not establish a connection.`,
            handler: {
                notFound: (handler) => `Function with handler "${handler}" was not found`
            },
            pullDocker: `Checking Docker image... failed`,
            tunnelPackageMissing: 'To run tunnel without Docker please: npm install -g @forge/sandbox-tunnel',
            dockerNotInstalled: (dockerDownloadLink) => 'Cannot find Docker. The tunnel command requires Docker to run your app locally. ' +
                `Get Docker at the following URL before rerunning the tunnel command:\n\n${dockerDownloadLink}`,
            dockerOutOfDate: (dockerDownloadLink) => 'The installed version of Docker should be 17.03 or greater. ' +
                `Update Docker at the following URL before rerunning the tunnel command:\n\n${dockerDownloadLink}`,
            dockerDaemonNotRunning: (err, isVerbose) => `Docker is not running. The tunnel command requires Docker to run your app locally. Open Docker before rerunning the tunnel command.` +
                `${isVerbose ? '\n\nError details: ' + err : ''}`,
            dockerPullFailed: (err) => `Cannot pull the tunnel image.`,
            serverNotStartedOnPort: (tunnelPort) => `Failed to connect to localhost:${tunnelPort}. Check that your service is running.`
        }
    },
    installationId: {
        prompt: "Enter the app's installation ID:",
        errors: {
            invalid: `Invalid installation ID. Run ${chalk_1.default.bold('forge install list')} to see the installation IDs for the app.`,
            notFound: (installationId) => `No installation found for installation ID: ${installationId}.`
        }
    },
    uninstall: {
        cmd: {
            desc: 'uninstall the app from an Atlassian site',
            start: 'Uninstalling...',
            success: (isMulti) => (isMulti ? 'Uninstalling...\n\n' : 'Uninstalled\n\n')
        },
        interactive: {
            desc: 'Select where to uninstall the app:',
            progressInfo: `To uninstall your app from a site, select it from the list.\nPress Ctrl+C to cancel.`,
            done: `\n${log_symbols_1.default.success} Apps uninstalled`
        },
        info: 'Uninstalling the app by installation ID.',
        done: (product, domain, environment, isMulti) => `${isMulti ? log_symbols_1.default.info : log_symbols_1.default.success} Uninstalled from the ${(0, environment_1.environmentToOption)(environment)} environment in ${product} on ${buildTerminalLink(domain)}.`,
        failed: (product, domain, environment) => `Failed to uninstall the app from the ${(0, environment_1.environmentToOption)(environment)} environment in ${product} on ${buildTerminalLink(domain)}. Try rerunning the command, or ask for help if you continue to see this error.`,
        missingUninstallTask: `Cannot uninstall the app: something went wrong with starting the uninstall task.`
    },
    webtrigger: {
        cmd: 'get a web trigger URL',
        copy: (url) => `\nCopy your web trigger URL below to start using it:\n\n${buildTerminalLink(url)}`,
        optionFuncKey: 'web trigger key from the manifest.yml file',
        overviewFuncKey: `\nGetting the web trigger URL by installation ID.\n\nPress Ctrl+C to cancel.\n`,
        promptFuncKey: 'Select a web trigger:',
        error: {
            funcKey: "The given web trigger key doesn't exist in the manifest.yml file.",
            noWebtriggers: "The manifest.yml file doesn't contain any web triggers. Add a web trigger before rerunning this command.",
            creationError: (message) => `Web trigger URL creation error: ${message}`
        }
    },
    logs: {
        cmd: 'view app logs',
        optionInvocation: 'view logs for a given invocation ID',
        optionLimit: 'number of invocations to return',
        optionGroup: 'group logs by invocation ID',
        optionSince: 'view logs since the specified time. valid formats: YYYY-MM-DD, ISO 8061 timestamp or a relative time (e.g: 5m, 10h, 2d)',
        invalidSinceOption: (since) => `Invalid date-time format: '${since}'. Date filter will not be applied.\n`
    },
    lint: {
        blurb: "The linter checks the app code for known errors. Warnings are issues you should fix, but they won't stop the app code from building.\nPress Ctrl+C to cancel.\n",
        cmd: 'check the source files for common errors',
        running: `Running ${chalk_1.default.bold('forge lint...')}`,
        noProblems: 'No issues found.',
        noFixableProblem: chalk_1.default.red('  Issue found is not automatically fixable with forge lint.'),
        noFixableProblems: chalk_1.default.red('  Issues found are not automatically fixable with forge lint.'),
        filename: chalk_1.default.underline,
        linterFailed: (linterClass, failure) => chalk_1.default.yellow(`${chalk_1.default.bold('Warning:')} Could not perform some linting actions for ${chalk_1.default.bold(linterClass)} due to unhandled error "${failure}".\n`),
        fixed: (numFixableErrors, numFixableWarnings) => {
            const { pluralCheckedFixableErrors, pluralCheckedFixableWarnings } = checkLintTotalPlurals(0, 0, numFixableErrors, numFixableWarnings);
            return `${greenTick} Fixed ${pluralCheckedFixableErrors} and ${pluralCheckedFixableWarnings}`;
        },
        fixFollowUp: `Run ${chalk_1.default.bold('forge lint')} to review outstanding errors and warnings`,
        error: (line, column, message, reference) => getLintMessage(line, column, message, 'error', log_color_1.LogColor.error, reference),
        summary: (numErrors, numWarnings, numFixableErrors, numFixableWarnings) => {
            const { pluralCheckedErrors, pluralCheckedWarnings, pluralCheckedTotal } = checkLintTotalPlurals(numErrors, numWarnings, numFixableErrors, numFixableWarnings);
            const colourFunction = numErrors ? log_color_1.LogColor.error : log_color_1.LogColor.warn;
            const warningCharacter = numErrors ? 'X' : '⚠';
            return colourFunction(`${warningCharacter} ${pluralCheckedTotal} (${pluralCheckedErrors}, ${pluralCheckedWarnings})`);
        },
        fixSummary: (numErrors, numFixableErrors, numFixableWarnings) => {
            const { pluralCheckedFixableErrors, pluralCheckedFixableWarnings } = checkLintTotalPlurals(0, 0, numFixableErrors, numFixableWarnings);
            const colourFunction = numErrors ? log_color_1.LogColor.error : log_color_1.LogColor.warn;
            return colourFunction(`  Run ${chalk_1.default.bold('forge lint --fix')} to automatically fix ${pluralCheckedFixableErrors} and ${pluralCheckedFixableWarnings}.\n`);
        },
        warning: (line, column, message, reference) => getLintMessage(line, column, message, 'warning', log_color_1.LogColor.warn, reference)
    },
    stub: {
        error: (newName, oldName) => `The ${chalk_1.default.bold(`forge ${oldName}`)} command has been deprecated and replaced by ${chalk_1.default.bold(`forge ${newName}`)}.`
    },
    customPrompts: {
        table: {
            promptMessage: (message) => `${chalk_1.default.green('?')} ${message}`,
            headerMessage: (message, singleOption) => `${chalk_1.default.bold(message)} ${chalk_1.default.dim(singleOption ? ' (Use the Enter key to select)' : ' (Use the spacebar to select multiple)')}`
        },
        singleSelectionTable: {
            doneHeaderMessage: (message) => `${chalk_1.default.bold(message)}`,
            decorateSelected: (site) => `${chalk_1.default.cyan(site)}`
        }
    },
    variables: {
        description: 'manage app environment variables'
    },
    settings: {
        description: 'manage Forge CLI settings',
        analytics: {
            banner: `We are continuously working to improve the developer experience in Forge. CLI usage helps us do just that. Select ${chalk_1.default.bold('yes')} below to agree to our collection of analytics data through our tools. You can use ${chalk_1.default.bold('forge settings')} to manage your settings at any time.`,
            promptMessage: 'Allow Forge to collect CLI usage and error reporting information?'
        },
        set: {
            description: (choices) => `update Forge CLI setting (choices: ${choices.join(', ')})`,
            invalidSetting: (choices) => `Invalid setting specified. Valid settings: ${choices.join(', ')}`,
            invalidValue: `Invalid value specified. Valid values: true, false`,
            success: (setting, value) => `${greenTick} Successfully set ${setting} as ${value}.`
        },
        list: {
            description: 'list Forge CLI settings'
        },
        usageAnalytics: {
            description: 'Allow Forge to collect CLI usage and error reporting information'
        },
        defaultEnvironment: {
            description: 'Change your default development environment',
            info: `To view all environments for this app, run ${chalk_1.default.bold('forge environments list')}.`
        }
    },
    nonInteractive: {
        description: 'run the command without input prompts',
        error: {
            missingRequiredOption: (command, requiredOptions) => `${command} --non-interactive requires ${requiredOptions.join(' ')}`,
            missingAnalyticsPreferences: `--non-interactive requires an analytics setting. Use ${chalk_1.default.bold('forge settings set usage-analytics <value>')}.`
        }
    }
};
