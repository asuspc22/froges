"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableTemplater = exports.TemplateServiceLister = exports.TemplateFetchError = exports.ZipTemplateExtractor = exports.TemplateServiceDownloader = exports.InvalidTemplateArchiveError = exports.NoTemplateError = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const fs_extra_1 = require("fs-extra");
const ignore_walk_1 = tslib_1.__importDefault(require("ignore-walk"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const path_1 = require("path");
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const url_1 = require("url");
const ui_1 = require("../ui");
const TEMPLATE_SERVICE_URL = 'https://forge-templates.us-west-2.prod.public.atl-paas.net/';
const TEMPLATE_MAP = 'templates.json';
class NoTemplateError extends Error {
    constructor(template) {
        super(ui_1.Text.create.error.template.notFound(template));
    }
}
exports.NoTemplateError = NoTemplateError;
class InvalidTemplateArchiveError extends Error {
}
exports.InvalidTemplateArchiveError = InvalidTemplateArchiveError;
class TemplateServiceDownloader {
    async download(template, zipFile) {
        const zipUrl = this.buildZipUrl(template);
        const fileStream = fs_1.default.createWriteStream(zipFile);
        const response = await (0, node_fetch_1.default)(zipUrl);
        if (!response.ok) {
            throw new NoTemplateError(template);
        }
        await new Promise((resolve) => {
            fileStream.on('finish', resolve);
            response.body.pipe(fileStream);
        });
    }
    buildZipUrl(template) {
        return new url_1.URL(`${template}.zip`, TEMPLATE_SERVICE_URL);
    }
}
exports.TemplateServiceDownloader = TemplateServiceDownloader;
class ZipTemplateExtractor {
    constructor(zipAccessor) {
        this.zipAccessor = zipAccessor;
    }
    async extract(zipFile, destDirectory) {
        const extractDirectory = tmp_1.default.dirSync({ prefix: 'template' }).name;
        try {
            await this.zipAccessor.extract(zipFile, extractDirectory);
            await this.moveArchiveFilesToDirectory(extractDirectory, destDirectory);
        }
        finally {
            (0, fs_extra_1.removeSync)(extractDirectory);
        }
    }
    async moveArchiveFilesToDirectory(extractDirectory, destDirectory) {
        const archiveChildren = fs_1.default.readdirSync(extractDirectory);
        if (archiveChildren.length !== 1) {
            throw new InvalidTemplateArchiveError(ui_1.Text.create.error.template.unexpectedArchiveFormat);
        }
        const templateRepoDirectory = (0, path_1.resolve)(extractDirectory, archiveChildren[0]);
        const templateEntries = await (0, ignore_walk_1.default)({
            path: templateRepoDirectory,
            ignoreFiles: ['.forgeignore']
        });
        const filteredEntries = templateEntries.filter((path) => (0, path_1.basename)(path) !== '.forgeignore');
        for (const entry of filteredEntries) {
            const entrySourceFullPath = (0, path_1.resolve)(templateRepoDirectory, entry);
            const entryDestFullPath = (0, path_1.resolve)(destDirectory, entry);
            (0, fs_extra_1.moveSync)(entrySourceFullPath, entryDestFullPath);
        }
    }
}
exports.ZipTemplateExtractor = ZipTemplateExtractor;
class TemplateFetchError extends Error {
    constructor() {
        super(ui_1.Text.error.templateFetchFailed);
    }
}
exports.TemplateFetchError = TemplateFetchError;
class TemplateServiceLister {
    isValidTemplateMapEntry(entry) {
        return typeof entry === 'object' && entry !== null && typeof entry.name === 'string';
    }
    isValidTemplatesResponse(response) {
        if (Array.isArray(response)) {
            return response.every((curr) => this.isValidTemplateMapEntry(curr));
        }
        return false;
    }
    async getAvailableTemplates() {
        try {
            const res = await (0, node_fetch_1.default)(new url_1.URL(TEMPLATE_MAP, TEMPLATE_SERVICE_URL));
            if (!res.ok) {
                throw new TemplateFetchError();
            }
            const json = await res.json();
            if (this.isValidTemplatesResponse(json)) {
                return json.map(({ name }) => name);
            }
            else {
                throw new TemplateFetchError();
            }
        }
        catch (e) {
            throw new TemplateFetchError();
        }
    }
}
exports.TemplateServiceLister = TemplateServiceLister;
class ComposableTemplater {
    constructor(downloader, extractor, lister, logger) {
        this.downloader = downloader;
        this.extractor = extractor;
        this.lister = lister;
        this.logger = logger;
    }
    async downloadAndExtract(template, directory) {
        this.logger.info(ui_1.Text.create.taskTemplate.title);
        const zipFile = tmp_1.default.fileSync({ postfix: '.zip' }).name;
        const destDirectory = (0, path_1.resolve)(process.cwd(), directory);
        try {
            (0, fs_extra_1.mkdirpSync)(destDirectory);
            this.logger.debug(ui_1.Text.create.taskTemplate.downloading(template));
            await this.downloader.download(template, zipFile);
            this.logger.debug(ui_1.Text.create.taskTemplate.extracting);
            await this.extractor.extract(zipFile, destDirectory);
        }
        catch (err) {
            (0, fs_extra_1.removeSync)(destDirectory);
            throw err;
        }
        finally {
            fs_1.default.unlinkSync(zipFile);
        }
    }
    getAvailableTemplates() {
        return this.lister.getAvailableTemplates();
    }
}
exports.ComposableTemplater = ComposableTemplater;
