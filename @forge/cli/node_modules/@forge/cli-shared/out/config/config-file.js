"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigFile = exports.ResourceDefinitionMissingError = void 0;
const tslib_1 = require("tslib");
const yaml_1 = tslib_1.__importStar(require("yaml"));
const util_1 = require("yaml/util");
const ui_1 = require("../ui");
const _1 = require("./");
const case_1 = tslib_1.__importDefault(require("case"));
const config_1 = require("./config");
const url_1 = require("url");
const shared_1 = require("../shared");
const runtimes_1 = require("../runtimes");
class ResourceDefinitionMissingError extends shared_1.UserError {
    constructor(resources) {
        super(ui_1.Text.error.resourceDefinitionMissing(resources));
    }
}
exports.ResourceDefinitionMissingError = ResourceDefinitionMissingError;
class ConfigFile {
    constructor(fileReader, fileWriter) {
        this.fileReader = fileReader;
        this.fileWriter = fileWriter;
    }
    async getAppHandlers() {
        var _a, _b;
        const config = await this.readConfig();
        const functions = (_b = (_a = config.modules) === null || _a === void 0 ? void 0 : _a.function) !== null && _b !== void 0 ? _b : [];
        const handlers = Array.from(new Set(functions.map((f) => f.handler)));
        return handlers.map((handler) => {
            const parts = handler.split('.');
            if (parts.length !== 2) {
                throw new shared_1.ValidationError(ui_1.Text.error.handlerFormat(handler));
            }
            const [module, func] = parts;
            return { module, func };
        });
    }
    async readConfig() {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFileName);
        try {
            yaml_1.default.scalarOptions.null.nullStr = '';
            return (0, yaml_1.parse)(manifestFileContents);
        }
        catch (_a) {
            throw new shared_1.ValidationError(ui_1.Text.artifact.error.invalidYaml(_1.manifestFileName));
        }
    }
    async readConfigToDocument() {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFileName);
        if (manifestFileContents) {
            try {
                return (0, yaml_1.parseDocument)(manifestFileContents);
            }
            catch (_a) {
                throw new shared_1.ValidationError(ui_1.Text.artifact.error.invalidYaml(_1.manifestFileName));
            }
        }
    }
    async snapshotsEnabled() {
        var _a, _b;
        const config = await this.readConfig();
        const entry = (_b = (_a = config.app) === null || _a === void 0 ? void 0 : _a.runtime) === null || _b === void 0 ? void 0 : _b.snapshots;
        return entry || entry === undefined;
    }
    async runtimeType() {
        var _a, _b;
        const config = await this.readConfig();
        const runtimeName = (_b = (_a = config.app) === null || _a === void 0 ? void 0 : _a.runtime) === null || _b === void 0 ? void 0 : _b.name;
        return (0, runtimes_1.getRuntimeType)(runtimeName);
    }
    makeManifestUnique(modules, appName) {
        const actualModules = {};
        for (const [moduleKey, moduleArray] of Object.entries(modules)) {
            actualModules[moduleKey] = moduleArray === null || moduleArray === void 0 ? void 0 : moduleArray.map((module) => {
                if (moduleKey !== 'function' && !moduleKey.startsWith(case_1.default.kebab(appName))) {
                    module['key'] = case_1.default.kebab([appName, module.key].join(' '));
                    if ('title' in module) {
                        module['title'] = appName;
                    }
                    if ('name' in module) {
                        module['name'] = appName;
                    }
                }
                return module;
            });
        }
        return actualModules;
    }
    async prependAppNameToModules(name) {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFileName);
        const currentConfigDoc = (0, yaml_1.parseDocument)(manifestFileContents || '');
        const modules = currentConfigDoc.get('modules');
        if (modules && modules.type === util_1.Type.MAP) {
            const modulesObject = modules.toJSON();
            const modulesWithUniqueName = this.makeManifestUnique(modulesObject, name);
            currentConfigDoc.set('modules', modulesWithUniqueName);
            this.fileWriter.writeStringToFile(currentConfigDoc.toString(), _1.manifestFileName);
        }
    }
    async writeToConfigFile(configKey, config) {
        const manifestFileContents = this.fileReader.readFile(_1.manifestFileName);
        const currentConfigDoc = (0, yaml_1.parseDocument)(manifestFileContents || '');
        Object.keys(config).forEach((key) => {
            if (config[key] === undefined) {
                delete config[key];
            }
        });
        currentConfigDoc.set(configKey, config);
        this.fileWriter.writeStringToFile(currentConfigDoc.toString(), _1.manifestFileName);
    }
    getHostedResourceModules(modules) {
        const modulesArray = Object.values(modules).flat();
        return modulesArray.filter((module) => (0, config_1.isHostedResourceModule)(module));
    }
    assertNoMissingResources(modules, resources) {
        const missingResources = modules.filter(({ resource }) => !resources.some(({ key }) => resource === key));
        if (missingResources.length > 0) {
            throw new ResourceDefinitionMissingError(missingResources.map((m) => m.resource));
        }
    }
    getRemoteFromEgressPermission(remoteEgressPermission, remotes) {
        if (!remotes) {
            return remoteEgressPermission;
        }
        for (const remote of remotes) {
            if (remote.key === remoteEgressPermission) {
                return new url_1.URL(remote.baseUrl).hostname;
            }
        }
        return remoteEgressPermission;
    }
    instanceOfRemote(remote) {
        return typeof remote !== 'string' && 'remote' in remote;
    }
    async getEgressPermissions() {
        const { permissions, remotes } = await this.readConfig();
        const egressPermissions = permissions === null || permissions === void 0 ? void 0 : permissions.external;
        if (!egressPermissions) {
            return [];
        }
        const { fetch: fetchEgress } = egressPermissions, otherEgress = tslib_1.__rest(egressPermissions, ["fetch"]);
        const getDomainsFromPermissions = (input, typePrefix = undefined) => Object.entries(input)
            .filter((entry) => Array.isArray(entry[1]))
            .map((entry) => {
            var _a;
            return ({
                type: typePrefix ? `${typePrefix}_${entry[0]}` : entry[0],
                domains: (_a = entry[1]) === null || _a === void 0 ? void 0 : _a.map((url) => {
                    let domain = this.instanceOfRemote(url) ? url.remote : url;
                    try {
                        domain = this.instanceOfRemote(url)
                            ? this.getRemoteFromEgressPermission(url.remote, remotes)
                            : new url_1.URL(url).hostname;
                    }
                    catch (e) {
                    }
                    return domain;
                })
            });
        });
        const egressUrls = getDomainsFromPermissions(otherEgress);
        const fetchUrls = fetchEgress ? getDomainsFromPermissions(fetchEgress, 'fetch') : [];
        return [...egressUrls, ...fetchUrls];
    }
    async getAuthProviders() {
        var _a;
        const config = await this.readConfig();
        return (((_a = config.providers) === null || _a === void 0 ? void 0 : _a.auth.reduce((hash, { key, name }) => {
            return Object.assign(hash, {
                [key]: {
                    key,
                    name
                }
            });
        }, {})) || {});
    }
    async getResources(resourceTypes) {
        const { modules, resources } = await this.readConfig();
        const hostedResourceModules = modules ? this.getHostedResourceModules(modules) : [];
        const maybeResources = resources || [];
        const validResources = maybeResources.filter(config_1.validateResource);
        this.assertNoMissingResources(hostedResourceModules, validResources);
        const validResourcesWithDetails = validResources.map((resource) => (Object.assign(Object.assign({}, resource), { resourceType: this.getResourceType(resource, hostedResourceModules) }))) || [];
        if (!resourceTypes) {
            return validResourcesWithDetails;
        }
        return validResourcesWithDetails.filter(({ resourceType }) => resourceTypes.includes(resourceType));
    }
    async getConnectKey() {
        var _a;
        const { app } = await this.readConfig();
        return (_a = app.connect) === null || _a === void 0 ? void 0 : _a.key;
    }
    getResourceType({ key: resourceKey }, allModules) {
        const linkedModule = allModules.find((m) => m.resource === resourceKey);
        if (!linkedModule) {
            return 'default';
        }
        return linkedModule.render === 'native' ? 'nativeUI' : 'customUI';
    }
}
exports.ConfigFile = ConfigFile;
