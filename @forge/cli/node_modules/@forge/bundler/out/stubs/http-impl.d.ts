/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { IncomingMessage } from 'http';
import { RequestOptions, AgentOptions } from 'https';
import { Writable } from 'readable-stream';
import { URL } from 'url';
import { FetchOptions } from '@forge/api';
export interface ChainableOptions {
    timeout?: number;
    headers: {
        [key: string]: string;
    };
}
export declare type Callback = (res: IncomingMessage) => void;
export declare type Arg = RequestOptions | string | URL | Callback;
export declare const isCallback: (options: Arg) => options is Callback;
export declare const isString: (options: Arg) => options is string;
export declare const isURL: (options: Arg) => options is URL;
export declare const isStringOrURL: (options: Arg) => options is string | URL;
export declare const isRequestOptions: (options: Arg) => options is RequestOptions;
export declare class Request extends Writable {
    private reqBody;
    private chainableOptions;
    constructor(options: RequestOptions | string | URL, callback?: Callback);
    setHeader(name: string, value: string): Request;
    setTimeout(value: number, callback?: () => void): Request;
    private fetch;
    _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;
    static formatUrl(options: RequestOptions): string;
    static urlFromFetchArgs(options: RequestOptions | string | URL): string;
    static convertToForgeFetchArgs(options: RequestOptions | string | URL, chainableOptions: ChainableOptions): {
        url: string;
        init: FetchOptions;
    };
    abort(): void;
}
export declare class Agent {
    constructor(options: AgentOptions);
}
//# sourceMappingURL=http-impl.d.ts.map