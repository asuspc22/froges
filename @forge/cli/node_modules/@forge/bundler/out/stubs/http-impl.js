"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = exports.Request = exports.isRequestOptions = exports.isStringOrURL = exports.isURL = exports.isString = exports.isCallback = void 0;
const readable_stream_1 = require("readable-stream");
const api_1 = require("@forge/api");
const HEADERS_DISCARD_DUPLICATES = new Set([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'server',
    'user-agent'
]);
class Response extends readable_stream_1.Readable {
    constructor(content, response) {
        super();
        this.statusCode = response.status;
        this.statusMessage = response.statusText;
        this.headers = {};
        this.headersDistinct = {};
        const rawHeaders = response.headers.raw();
        for (const [name, values] of Object.entries(rawHeaders)) {
            if (name === 'content-encoding') {
                continue;
            }
            let value;
            if (HEADERS_DISCARD_DUPLICATES.has(name)) {
                value = values[0];
            }
            else if (name === 'set-cookie') {
                value = values;
            }
            else if (name === 'cookie') {
                value = values.join('; ');
            }
            else {
                value = values.join(', ');
            }
            this.headers[name] = value;
            this.headersDistinct[name] = values;
        }
        this._read = () => { };
        this.push(Buffer.from(content));
        this.push(null);
    }
}
const isCallback = (options) => typeof options === 'function';
exports.isCallback = isCallback;
const isString = (options) => typeof options === 'string';
exports.isString = isString;
const isURL = (options) => typeof options === 'object' && options.constructor.name === 'URL';
exports.isURL = isURL;
const isStringOrURL = (options) => (0, exports.isString)(options) || (0, exports.isURL)(options);
exports.isStringOrURL = isStringOrURL;
const isRequestOptions = (options) => !(0, exports.isStringOrURL)(options) && !(0, exports.isCallback)(options);
exports.isRequestOptions = isRequestOptions;
class Request extends readable_stream_1.Writable {
    constructor(options, callback) {
        super();
        this.reqBody = [];
        this.chainableOptions = {
            headers: {}
        };
        if (callback) {
            this.on('response', callback);
        }
        this.on('finish', this.fetch.bind(this, options));
    }
    setHeader(name, value) {
        this.chainableOptions.headers[name] = value;
        return this;
    }
    setTimeout(value, callback) {
        this.chainableOptions.timeout = value;
        if (callback) {
            this.on('timeout', callback);
        }
        return this;
    }
    fetch(options) {
        const { url, init } = Request.convertToForgeFetchArgs(options, this.chainableOptions);
        if (init.method && init.method !== 'HEAD' && init.method !== 'GET') {
            init.body = Buffer.concat(this.reqBody);
        }
        (0, api_1.fetch)(url, init)
            .then(async (response) => {
            const content = await response.arrayBuffer();
            const transformedAPIResponse = new Response(content, response);
            this.emit('response', transformedAPIResponse);
        })
            .catch((err) => {
            if (err.message.startsWith('network timeout')) {
                this.emit('timeout');
            }
            else {
                this.emit('error', err);
            }
        });
    }
    _write(chunk, encoding, callback) {
        try {
            if (Buffer.isEncoding(encoding)) {
                this.reqBody.push(Buffer.from(chunk, encoding));
            }
            else if (Buffer.isBuffer(chunk)) {
                this.reqBody.push(chunk);
            }
            else {
                this.reqBody.push(Buffer.from(chunk));
            }
            callback();
        }
        catch (err) {
            callback(err);
        }
    }
    static formatUrl(options) {
        var _a, _b;
        const protocol = 'https:';
        const auth = options.auth ? `${options.auth}@` : '';
        const host = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host;
        const port = options.port ? `:${options.port}` : '';
        const path = (_b = options.path) !== null && _b !== void 0 ? _b : '/';
        return `${protocol}//${auth}${host}${port}${path}`;
    }
    static urlFromFetchArgs(options) {
        if ((0, exports.isString)(options)) {
            return options;
        }
        else if ((0, exports.isURL)(options)) {
            return options.toString();
        }
        else {
            try {
                return Request.formatUrl(options);
            }
            catch (err) {
                console.error('Unable to make request with unrecognised URL options:', options);
                throw err;
            }
        }
    }
    static convertToForgeFetchArgs(options, chainableOptions) {
        const url = Request.urlFromFetchArgs(options);
        if ((0, exports.isStringOrURL)(options)) {
            return { url, init: chainableOptions };
        }
        else {
            const reqOpts = {};
            if (options.headers) {
                reqOpts.headers = {};
                for (const header in options.headers) {
                    const headerValue = options.headers[header];
                    if (headerValue) {
                        reqOpts.headers[header] = headerValue.toString();
                    }
                }
            }
            if (options.timeout)
                reqOpts.timeout = options.timeout;
            reqOpts.method = options.method || 'GET';
            return { url, init: Object.assign(Object.assign({}, chainableOptions), reqOpts) };
        }
    }
    abort() {
    }
}
exports.Request = Request;
const NUM_SUPPORTED_AGENT_OPTIONS = 1;
class Agent {
    constructor(options) {
        if (Object.keys(options).length > NUM_SUPPORTED_AGENT_OPTIONS) {
            console.warn("Forge only supports 'keepAlive' as an option to http.Agent");
        }
        return { keepAlive: options.keepAlive };
    }
}
exports.Agent = Agent;
