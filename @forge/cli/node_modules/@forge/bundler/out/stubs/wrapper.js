"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@forge/api");
const runtime_1 = require("@forge/runtime");
const console_1 = require("./console");
const http_node_1 = require("./http-node");
const log_events_1 = require("./log-events");
const wrappedFilename = __filename.replace(/\/[^/]+.js$/, (name) => '/bundled' + name);
const realRequire = eval('require');
if (!realRequire) {
    throw new Error(`Unexpected require: ${realRequire}`);
}
const bundledExports = eval('__BUNDLED_EXPORTS__');
if (!bundledExports || bundledExports.length === 0) {
    throw new Error('Expected to find __BUNDLED_EXPORTS__ replaced by Webpack configuration.');
}
const adapter = (name) => {
    return async (lambdaEvent, lambdaContext) => {
        var _a, _b;
        const event = lambdaEvent.body;
        const context = (0, runtime_1.setupRequestContext)({ meta: lambdaEvent._meta, handler: lambdaEvent.handler });
        const metricsCollector = new runtime_1.MetricsCollector(new runtime_1.InMemoryMetrics({ runtime: 'nodejs' }));
        const metrics = metricsCollector.metrics();
        const rms = lambdaEvent._meta.rms;
        const runtime = Object.assign(Object.assign({ proxy: lambdaEvent._meta.proxy, contextAri: lambdaEvent._meta.contextAri, appContext: lambdaEvent._meta.appContext, allowedEgress: (_a = lambdaEvent._meta.fetchAllowList) !== null && _a !== void 0 ? _a : [], lambdaContext: lambdaContext, tracing: lambdaEvent._meta.tracing }, (rms && { rms })), { metrics });
        global.__forge_runtime__ = runtime;
        for (const { key, value } of (_b = lambdaEvent.variables) !== null && _b !== void 0 ? _b : []) {
            process.env[key] = value;
        }
        try {
            const header = (0, log_events_1.emitHeaderEvent)(lambdaEvent);
            (0, console_1.replaceConsole)(header);
            (0, http_node_1.replaceHttps)();
            const timer = metrics.timing('invoke').measure();
            const bundled = realRequire(wrappedFilename);
            let result;
            try {
                result = await bundled[name](event, context);
            }
            finally {
                timer.stop();
            }
            (0, log_events_1.emitSuccessfulFooterEvent)();
            return {
                success: true,
                body: result,
                metrics: metricsCollector.collectMetrics()
            };
        }
        catch (err) {
            console.error(err);
            (0, log_events_1.emitFailedFooterEvent)();
            const errorName = (0, api_1.isForgePlatformError)(err) ? err.name : api_1.FUNCTION_ERR;
            return {
                success: false,
                error: {
                    errorMessage: err.message,
                    errorType: errorName,
                    isHostedCodeError: (0, api_1.isHostedCodeError)(errorName),
                    stack: (err.stack || '').split('\n'),
                    serviceKey: err.serviceKey
                },
                metrics: metricsCollector.collectMetrics()
            };
        }
    };
};
(_b = (_a = process).setSourceMapsEnabled) === null || _b === void 0 ? void 0 : _b.call(_a, true);
for (const ownExport of bundledExports) {
    exports[ownExport] = adapter(ownExport);
}
