"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nativeUiBundle = exports.nodeBundle = exports.sandboxBundle = exports.createBundler = exports.watch = exports.runLinter = exports.getCompiler = exports.getInMemoryBundle = exports.handleWebpackCompilationResult = void 0;
const tslib_1 = require("tslib");
const memfs_1 = require("memfs");
const webpack_1 = tslib_1.__importDefault(require("webpack"));
const path_1 = tslib_1.__importDefault(require("path"));
const text_1 = require("./text");
const cli_shared_1 = require("@forge/cli-shared");
const lint_1 = require("@forge/lint");
const sandbox_1 = require("./config/sandbox");
const node_1 = require("./config/node");
const nativeui_1 = require("./config/nativeui");
const compilerOutputFileSystem = (0, memfs_1.createFsFromVolume)(new memfs_1.Volume());
const readMemoryFileSync = (outputFileSystem, filePath) => {
    return outputFileSystem.readFileSync(filePath, { encoding: 'utf8' }).toString();
};
function handleWebpackCompilationResult(logger, err, stats) {
    if (err) {
        throw err;
    }
    if (!stats) {
        throw new Error('bundle function callback returns empty stats');
    }
    const info = stats.toJson();
    if (stats.hasErrors() && info.errors) {
        const isTSError = info.errors.every((e) => e.message.includes('[tsl]'));
        if (isTSError) {
            const formattedErrors = info.errors.map((error) => {
                return error.message.replace(/\.?.+.tsx?(?!\([0-9]\,[0-9]\))$/gm, '');
            });
            throw new cli_shared_1.BundlerTSError(text_1.Text.typescriptError(formattedErrors));
        }
        else {
            throw new Error(text_1.Text.genericBundlingError(info.errors.map((e) => e.message)));
        }
    }
    if (stats.hasWarnings() && info.warnings) {
        for (const warning of info.warnings) {
            logger.warn(warning.message);
        }
    }
}
exports.handleWebpackCompilationResult = handleWebpackCompilationResult;
function getInMemoryBundle(config, fileSystem) {
    const output = {}, sourceMap = {};
    const outputFileSystem = fileSystem || compilerOutputFileSystem;
    for (const name in config.entry) {
        output[name] = readMemoryFileSync(outputFileSystem, `/${name}.js`).toString();
        try {
            sourceMap[name] = readMemoryFileSync(outputFileSystem, `/${name}.js.map`);
        }
        catch (e) {
        }
    }
    return { output, sourceMap };
}
exports.getInMemoryBundle = getInMemoryBundle;
const getCompiler = (webpackConfig, options) => {
    const compiler = (0, webpack_1.default)(webpackConfig);
    if (!(options === null || options === void 0 ? void 0 : options.writeToDisk)) {
        compiler.outputFileSystem = compilerOutputFileSystem;
    }
    return compiler;
};
exports.getCompiler = getCompiler;
const getNodeModuleNames = (stats) => {
    const { modules } = stats.toJson({ modules: true });
    if (modules) {
        const filteredModuleNames = new Set();
        modules
            .map((m) => m.name || '')
            .forEach((name) => {
            const parts = name.match(/^\.\/node_modules\/([^/]+)\/([^/]+)/);
            if (parts) {
                const module = parts[1][0] === '@' ? `${parts[1]}/${parts[2]}` : parts[1];
                filteredModuleNames.add(module);
            }
            else if (name.includes('unsupported.js')) {
                filteredModuleNames.add(name.slice(name.indexOf('?')));
            }
        });
        return Array.from(filteredModuleNames);
    }
};
class Monitor {
    constructor(watcher) {
        this.watcher = watcher;
    }
    stop() {
        this.watcher.close(() => null);
    }
}
const runLinter = async (logger = { info: console.log }, fileSystemReader = new cli_shared_1.FileSystemReader(), fileSystemWriter = new cli_shared_1.FileSystemWriter()) => {
    logger.info(`\n${cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.lint.running)}`);
    const exclude = [...(await (0, cli_shared_1.listGitIgnoreFiles)(fileSystemReader)), '.git', 'node_modules'];
    const configFile = new cli_shared_1.ConfigFile(fileSystemReader, fileSystemWriter);
    const manifest = await configFile.readConfig();
    const csuikResources = await configFile.getResources(['nativeUI']);
    const csuikDirectories = csuikResources.map((resource) => path_1.default.dirname(resource.path));
    const [filesToLint, ...csuikFilesByDirectory] = await Promise.all([
        fileSystemReader.recursiveReadDir('./src', exclude),
        ...csuikDirectories.map((directory) => fileSystemReader.recursiveReadDir(directory, exclude))
    ]);
    const csuikFilesToLint = csuikFilesByDirectory.reduce((allFiles, directoryFiles) => allFiles.concat(directoryFiles), []);
    try {
        const lintResults = await (0, lint_1.lint)([...filesToLint, ...csuikFilesToLint], manifest, 'development', logger);
        if (lintResults.some((result) => result.size())) {
            logger.info('');
            (0, lint_1.reportLintResults)(logger, lintResults);
        }
        else {
            logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.lint.noProblems) + '\n');
        }
    }
    catch (error) {
        logger.info(cli_shared_1.Text.tunnel.lintFailed + '\n');
    }
};
exports.runLinter = runLinter;
const watch = (logger, entryPoints, debugMode, callback, watchRun) => {
    const config = (0, sandbox_1.getSandboxedRuntimeBuildConfig)(entryPoints, {
        isWatchMode: true,
        isDebugMode: debugMode,
        appDirectory: process.cwd()
    });
    const compiler = (0, exports.getCompiler)(config);
    if (typeof watchRun === 'function') {
        compiler.hooks.watchRun.tapAsync('watchRun', (watchRunCompiler, watchRunCallback) => {
            watchRun(watchRunCompiler, exports.runLinter, watchRunCallback);
        });
    }
    const watcher = compiler.watch({ poll: 1000 }, (compilerError, stats) => {
        try {
            handleWebpackCompilationResult(logger, compilerError, stats);
            callback(null, getInMemoryBundle(config));
        }
        catch (fileReadError) {
            callback(fileReadError);
        }
    });
    return new Monitor(watcher);
};
exports.watch = watch;
function createBundler(getBuildConfig) {
    return (logger, appDirectory, endpoints) => {
        const config = getBuildConfig(endpoints, { isWatchMode: false, appDirectory });
        const compiler = (0, exports.getCompiler)(config);
        return new Promise((resolve, reject) => {
            compiler.run((compilerError, stats) => {
                try {
                    handleWebpackCompilationResult(logger, compilerError, stats);
                    const result = getInMemoryBundle(config);
                    compiler.close((closeError) => {
                        if (closeError) {
                            reject(closeError);
                        }
                    });
                    result.metadata = {
                        modules: getNodeModuleNames(stats)
                    };
                    resolve(result);
                }
                catch (fileReadError) {
                    reject(fileReadError);
                }
            });
        });
    };
}
exports.createBundler = createBundler;
exports.sandboxBundle = createBundler(sandbox_1.getSandboxedRuntimeBuildConfig);
exports.nodeBundle = createBundler(node_1.getNodeRuntimeBuildConfig);
const nativeUiBundle = (logger, entrypoints) => {
    const config = (0, nativeui_1.getNativeUiBuildConfig)(entrypoints);
    const compiler = (0, exports.getCompiler)(config, { writeToDisk: true });
    return new Promise((resolve, reject) => {
        compiler.run((compilerError, stats) => {
            try {
                handleWebpackCompilationResult(logger, compilerError, stats);
                resolve({
                    outputDir: config.output.path
                });
            }
            catch (err) {
                reject(err);
            }
        });
    });
};
exports.nativeUiBundle = nativeUiBundle;
