"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayConditionsValidator = void 0;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const text_1 = require("../text");
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]';
const errors = text_1.errors.modules.displayConditions;
class DisplayConditionsValidator {
    constructor(schema) {
        var _a, _b, _c;
        this.schema = schema;
        const ajv = new ajv_1.default({ allErrors: true, jsonPointers: true, verbose: true, extendRefs: true });
        this.validateSchema = ajv.compile(this.schema);
        const properties = this.schema.properties;
        this.moduleSchemas = (_a = properties.modules) === null || _a === void 0 ? void 0 : _a.properties;
        this.supportedOperations = (_c = (_b = properties.operations) === null || _b === void 0 ? void 0 : _b.items) === null || _c === void 0 ? void 0 : _c.enum;
    }
    flattenDisplayConditions(moduleKey, displayConditions, nesting = 0) {
        if (nesting >= 10) {
            throw Error(errors.overcomplicated(moduleKey));
        }
        if (Array.isArray(displayConditions)) {
            return [displayConditions];
        }
        const result = [];
        const obj = {};
        const keys = Object.keys(displayConditions);
        for (let i = 0; i < keys.length; i += 1) {
            if (this.supportedOperations.includes(keys[i])) {
                result.push(...this.flattenDisplayConditions(moduleKey, displayConditions[keys[i]], nesting + 1));
            }
            else {
                obj[keys[i]] = displayConditions[keys[i]];
            }
        }
        return [...result, obj].filter((entry) => Object.keys(entry).length > 0);
    }
    toValidationError(message) {
        return {
            message,
            reference: text_1.References.SchemaError,
            level: 'error',
            line: 0,
            column: 0
        };
    }
    async validate(manifest) {
        if (!manifest ||
            !manifest.typedContent ||
            (!manifest.typedContent.modules && !manifest.typedContent.connectModules)) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        const { typedContent: { modules } } = manifest;
        if (!modules) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        const validationErrors = new Map();
        const reportError = (moduleKey, dataPath, message) => {
            const key = `${moduleKey}__${dataPath}`;
            if (!validationErrors.has(key)) {
                validationErrors.set(key, this.toValidationError(message));
            }
        };
        Object.keys(this.moduleSchemas).forEach((m) => {
            var _a;
            (_a = modules[m]) === null || _a === void 0 ? void 0 : _a.forEach((module) => {
                if (!module.displayConditions) {
                    return;
                }
                if (!isPlainObject(module.displayConditions)) {
                    reportError(module.key, 'n/a', errors.invalid(module.key));
                    return;
                }
                let displayConditions = [];
                try {
                    displayConditions = this.flattenDisplayConditions(module.key, module.displayConditions);
                }
                catch (e) {
                    reportError(module.key, 'n/a', e.message);
                    return;
                }
                displayConditions.forEach((result) => {
                    var _a;
                    void this.validateSchema({ modules: { [m]: result } });
                    (_a = this.validateSchema.errors) === null || _a === void 0 ? void 0 : _a.forEach((error) => {
                        const { keyword, dataPath, params, message } = error;
                        const split = dataPath.split('/');
                        const path = String(split.pop());
                        if (keyword === 'type' && message) {
                            if (path === String(Number(path))) {
                                reportError(module.key, dataPath, errors.typeMismatch(module.key, `${split.pop()}[${path}]`, message));
                            }
                            else {
                                reportError(module.key, dataPath, errors.typeMismatch(module.key, path, message));
                            }
                        }
                        else if (keyword === 'additionalProperties' && params) {
                            reportError(module.key, dataPath, errors.propertyNotAllowed(module.key, String(params.additionalProperty)));
                        }
                        else {
                            reportError(module.key, dataPath, errors.invalid(module.key));
                        }
                    });
                });
            });
        });
        return {
            success: validationErrors.size === 0,
            manifestObject: manifest,
            errors: Array.from(validationErrors.values())
        };
    }
}
exports.DisplayConditionsValidator = DisplayConditionsValidator;
