"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateKeyboardShortcuts = void 0;
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const VALID_SINGLE_KEY = new RegExp(/^[^+ ]$/);
const INVALID_COMBINATION_SYNTAX = new RegExp(/(^\+$| \+|\+ )/);
const MODIFIER_KEYS = new Set(['shift', 'ctrl', 'alt', 'option', 'meta', 'command', 'mod']);
const SPECIAL_KEYS = new Set([
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'f10',
    'f11',
    'f12',
    'backspace',
    'tab',
    'enter',
    'return',
    'capslock',
    'esc',
    'escape',
    'pageup',
    'pagedown',
    'end',
    'home',
    'left',
    'up',
    'right',
    'down',
    'ins',
    'del',
    'space',
    'plus'
]);
const VALID_NAMED_KEYS = new Set([...MODIFIER_KEYS, ...SPECIAL_KEYS]);
const errorMessages = text_1.errors.modules.confluence.keyboardShortcuts;
const isValidKey = (key) => VALID_NAMED_KEYS.has(key) || !!key.match(VALID_SINGLE_KEY);
const mapToKeyboardShortcutError = (validationErrors, moduleKey) => validationErrors.map((message) => ({ moduleKey, message }));
const validateWhitespaceAndSyntax = (accelerator) => {
    const validationErrors = [];
    if (!accelerator || accelerator.trim() === '') {
        validationErrors.push(errorMessages.emptyAccelerator());
    }
    else if (accelerator.startsWith(' ') || accelerator.endsWith(' ')) {
        validationErrors.push(errorMessages.spaceAroundAccelerator(accelerator));
    }
    else if (accelerator.match(INVALID_COMBINATION_SYNTAX)) {
        validationErrors.push(errorMessages.invalidPlusSyntax(accelerator));
    }
    return validationErrors;
};
const modifierKeysPrecedeNonModifierKey = (modifierKeys, nonModifierKeys, keys) => {
    if (modifierKeys.length && nonModifierKeys.length) {
        const indexOfNonModifierKey = keys.indexOf(nonModifierKeys[0]);
        const indexOfLastKey = keys.length - 1;
        return indexOfNonModifierKey === indexOfLastKey;
    }
    return true;
};
const validateModifierKeys = (accelerator, keys) => {
    const validationErrors = [];
    const nonModifierKeys = keys.filter((key) => !MODIFIER_KEYS.has(key));
    if (nonModifierKeys.length > 1) {
        validationErrors.push(errorMessages.moreThanOneNonModifierKey(accelerator));
    }
    const modifierKeys = keys.filter((key) => MODIFIER_KEYS.has(key));
    if (!modifierKeysPrecedeNonModifierKey(modifierKeys, nonModifierKeys, keys)) {
        validationErrors.push(errorMessages.modifierKeysShouldPrecedeNonModifierKey(accelerator));
    }
    return validationErrors;
};
const validateKeyCombinationsAndSequences = (accelerator) => {
    const validationErrors = [];
    const sequence = accelerator.split(' ');
    for (const combination of sequence) {
        const keys = combination.split('+');
        const uniqueKeys = new Set(keys);
        const allDifferent = keys.length === uniqueKeys.size;
        if (!allDifferent) {
            validationErrors.push(errorMessages.combinationKeysAreNotUnique(accelerator));
        }
        validationErrors.push(...validateModifierKeys(accelerator, [...uniqueKeys]));
        for (const key of keys) {
            if (!isValidKey(key)) {
                validationErrors.push(errorMessages.invalidKey(accelerator, key));
            }
        }
    }
    return validationErrors;
};
const validateShortcut = (moduleKey, accelerator) => {
    const whitespaceAndSyntaxErrors = validateWhitespaceAndSyntax(accelerator);
    if (whitespaceAndSyntaxErrors.length) {
        return mapToKeyboardShortcutError(whitespaceAndSyntaxErrors, moduleKey);
    }
    return mapToKeyboardShortcutError(validateKeyCombinationsAndSequences(accelerator), moduleKey);
};
const validateKeyboardShortcuts = (allModules, yamlContentByLine) => {
    const validationErrors = [];
    const modules = (0, utils_1.getAllModules)(allModules) || [];
    const modulesWithKeyboardShortcut = modules.filter((module) => { var _a; return (_a = module === null || module === void 0 ? void 0 : module.keyboardShortcut) === null || _a === void 0 ? void 0 : _a.accelerator; });
    if (modulesWithKeyboardShortcut.length > 0) {
        modulesWithKeyboardShortcut.forEach((m) => validationErrors.push(...validateShortcut(m.key, m.keyboardShortcut.accelerator).map((e) => (Object.assign({ message: e.message, reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(e.moduleKey, yamlContentByLine))))));
    }
    return validationErrors;
};
exports.validateKeyboardShortcuts = validateKeyboardShortcuts;
