"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCustomContentHierarchy = void 0;
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const INNER_TYPE_PREFIX = 'this:';
const validateCustomContentHierarchy = (allModules, moduleType, yamlContentByLine) => {
    const validationErrors = [];
    const modules = allModules[moduleType] || [];
    modules.forEach((module) => {
        const supportedContainerTypes = module.supportedContainerTypes || [];
        const supportedChildTypes = module.supportedChildTypes || [];
        [
            {
                propName: 'supportedContainerTypes',
                propInnerValues: supportedContainerTypes.filter((supportedContainerType) => supportedContainerType.startsWith(INNER_TYPE_PREFIX)),
                dependentPropName: 'supportedChildTypes',
                dependentReferenceMissingMessage: text_1.errors.modules.confluence.validateCustomContentCrossReferenceMissingContainer
            },
            {
                propName: 'supportedChildTypes',
                propInnerValues: supportedChildTypes.filter((supportedChildType) => supportedChildType.startsWith(INNER_TYPE_PREFIX)),
                dependentPropName: 'supportedContainerTypes',
                dependentReferenceMissingMessage: text_1.errors.modules.confluence.validateCustomContentCrossReferenceMissingChild
            }
        ].forEach(({ propName, propInnerValues, dependentPropName, dependentReferenceMissingMessage }) => {
            propInnerValues.forEach((value) => {
                const referredModuleName = value.substring(INNER_TYPE_PREFIX.length);
                const referredModule = modules.find((m) => m.key === referredModuleName);
                if (!referredModule) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.confluence.validateCustomContentHierarchyUnknown(propName, module.key, referredModuleName), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                }
                else {
                    const referredModuleDependentPropValues = referredModule[dependentPropName] || [];
                    if (!referredModuleDependentPropValues.includes(`${INNER_TYPE_PREFIX}${module.key}`)) {
                        validationErrors.push(Object.assign({ message: dependentReferenceMissingMessage(module.key, referredModule.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                    }
                }
            });
        });
    });
    return validationErrors;
};
exports.validateCustomContentHierarchy = validateCustomContentHierarchy;
