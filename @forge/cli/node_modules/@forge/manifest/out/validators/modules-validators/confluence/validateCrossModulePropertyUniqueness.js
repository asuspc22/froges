"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCrossModulePropertyUniqueness = void 0;
const tslib_1 = require("tslib");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const validateCrossModulePropertyUniqueness = (allModules, property, yamlContentByLine) => {
    var _a;
    const validationErrors = [];
    const modules = (0, utils_1.getAllModules)(allModules) || [];
    const allPropertyValues = modules.map((module) => (0, get_1.default)(module, property)).filter((propertyValue) => propertyValue);
    const duplicatePropertyValues = allPropertyValues.filter((propertyValue, index, all) => all.indexOf(propertyValue) !== index);
    if (duplicatePropertyValues.length > 0) {
        const allModulesWithDuplicatedPropertyValues = modules.filter((module) => (0, get_1.default)(module, property) === duplicatePropertyValues[0]);
        validationErrors.push(Object.assign({ message: text_1.errors.modules.confluence.crossModulePropertyUniqueness(property, duplicatePropertyValues), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)((_a = allModulesWithDuplicatedPropertyValues === null || allModulesWithDuplicatedPropertyValues === void 0 ? void 0 : allModulesWithDuplicatedPropertyValues[0]) === null || _a === void 0 ? void 0 : _a.key, yamlContentByLine)));
    }
    return validationErrors;
};
exports.validateCrossModulePropertyUniqueness = validateCrossModulePropertyUniqueness;
