"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaValidator = void 0;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const utils_1 = require("../utils");
const text_1 = require("../text");
class SchemaValidator {
    constructor(schema) {
        this.schema = schema;
        this.processErrorMessage = (error) => {
            var _a;
            if (error.keyword === 'required' && error.schemaPath.includes('oneOf')) {
                return undefined;
            }
            if (error.keyword === 'not') {
                return text_1.errors.schema.notAllowed(error.schema.required);
            }
            if (error.keyword === 'enum') {
                return text_1.errors.schema.enumValues(error.params.allowedValues);
            }
            if (error.keyword === 'oneOf') {
                if (error.params.passingSchemas) {
                    const requiredProps = error.params.passingSchemas.map((v) => error.schema[v].required);
                    return text_1.errors.schema.oneOf(requiredProps);
                }
                else if ((_a = error.parentSchema) === null || _a === void 0 ? void 0 : _a.oneOf) {
                    const requiredProps = error.parentSchema.oneOf
                        .map((v) => v.required)
                        .filter((v) => !!v);
                    return text_1.errors.schema.oneOf(requiredProps);
                }
                return text_1.errors.schema.oneOf(undefined);
            }
            if (error.keyword === 'additionalProperties' && 'additionalProperty' in error.params) {
                return text_1.errors.schema.additionalProperties(error.params.additionalProperty);
            }
            return error.message;
        };
        this.handleModuleError = (path, error, manifest) => {
            const hasProperty = path.length > 1;
            const propertyName = path[path.length - 1];
            const errorMessage = this.processErrorMessage(error);
            if (!errorMessage) {
                return undefined;
            }
            if (hasProperty) {
                path.splice(path.length - 1, 0, 'property');
            }
            const data = typeof error.data !== 'string' ? undefined : error.data;
            const searchString = data && hasProperty ? `${propertyName}: ${data}` : path[0];
            return Object.assign({ message: text_1.errors.schemaError(data, path, errorMessage), reference: text_1.References.SchemaError, level: 'error' }, (0, utils_1.findPosition)(searchString, manifest.yamlContentByLine));
        };
        this.handleGenericError = (path, error, manifest) => {
            const hasProperty = path.length > 1;
            const propertyName = path[path.length - 1];
            const errorMessage = this.processErrorMessage(error);
            if (!errorMessage) {
                return undefined;
            }
            if (hasProperty) {
                path.splice(path.length - 1, 0, 'property');
            }
            const data = typeof error.data !== 'string' ? undefined : error.data;
            const searchString = error.data && hasProperty ? `${propertyName}: ${error.data}` : propertyName;
            return Object.assign({ message: text_1.errors.schemaError(data, path, errorMessage), reference: text_1.References.SchemaError, level: 'error' }, (0, utils_1.findPosition)(searchString, manifest.yamlContentByLine));
        };
        this.isDeprecatedField = (section, error) => {
            if (error.keyword === 'additionalProperties') {
                return section === 'app' && error.params.additionalProperty === 'name';
            }
            return false;
        };
        this.handleDeprecatedField = (section, error, manifest) => {
            const property = error.params.additionalProperty;
            return Object.assign({ message: text_1.errors.schema.deprecatedValue(section, property, this.getDeprecationInfo(section, property)), reference: text_1.References.Deprecated, level: 'warning' }, (0, utils_1.findPosition)(`${section}:`, manifest.yamlContentByLine));
        };
        this.handleError = (path, error, manifest) => {
            const rootManifestSection = path[0];
            const manifestSection = path[path.length - 1];
            if (this.isDeprecatedField(manifestSection, error)) {
                return this.handleDeprecatedField(manifestSection, error, manifest);
            }
            if (rootManifestSection === 'modules') {
                return this.handleModuleError(path.slice(1), error, manifest);
            }
            return this.handleGenericError(path, error, manifest);
        };
        const ajv = new ajv_1.default({ allErrors: true, jsonPointers: true, verbose: true, extendRefs: true });
        this.validateSchema = ajv.compile(this.schema);
    }
    getDeprecationInfo(section, property) {
        const deprecationInfo = text_1.errors.deprecationInfo;
        const deprecationSection = deprecationInfo[section];
        if (!deprecationSection) {
            return undefined;
        }
        else {
            return deprecationSection[property];
        }
    }
    async validate(manifest) {
        var _a;
        if (!manifest || !manifest.yamlContent) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        let success = this.validateSchema(manifest.yamlContent);
        const errors = (_a = this.validateSchema.errors) === null || _a === void 0 ? void 0 : _a.map((error) => {
            const values = error.dataPath.replace(/\/\d+/, '').split('/').slice(1);
            return this.handleError(values, error, manifest);
        }).filter((e) => e !== undefined);
        const _isEqual = (e1, e2) => {
            return (e1.level === e2.level &&
                e1.reference === e2.reference &&
                e1.column === e2.column &&
                e1.line === e2.line &&
                e1.message === e2.message);
        };
        const dedupedErrors = [];
        void (errors === null || errors === void 0 ? void 0 : errors.forEach((e) => {
            if (!(dedupedErrors.filter((de) => _isEqual(e, de)).length > 0)) {
                dedupedErrors.push(e);
            }
        }));
        const warningLevel = dedupedErrors.filter((e) => e.level === 'warning');
        if (warningLevel.length === dedupedErrors.length) {
            success = true;
        }
        return {
            success,
            manifestObject: Object.assign(Object.assign({}, manifest), { typedContent: success ? manifest.yamlContent : undefined }),
            errors: dedupedErrors
        };
    }
}
exports.SchemaValidator = SchemaValidator;
