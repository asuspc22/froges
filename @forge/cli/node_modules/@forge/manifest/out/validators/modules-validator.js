"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModulesValidator = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
const text_1 = require("../text");
const fs_1 = require("fs");
const path_1 = require("path");
const ui_modifications_1 = require("./modules-validators/jira/ui-modifications");
const confluence_1 = require("./modules-validators/confluence");
const validate_full_admin_page_1 = require("./modules-validators/jira/validate-full-admin-page");
const validate_subpages_in_module_1 = require("./modules-validators/jira/validate-subpages-in-module");
class ModulesValidator {
    constructor() {
        this.functionHandlerRegex = /^([a-zA-Z0-9-_]+)\.([a-zA-Z0-9-_]+)$/;
    }
    async validate(manifest) {
        var _a, _b, _c;
        if (!manifest || !manifest.typedContent || !manifest.filePath) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        const validationErrors = [];
        this.connectModuleValidation(manifest, validationErrors);
        if (manifest.typedContent.modules) {
            const { typedContent: { modules, remotes, permissions }, yamlContentByLine, filePath } = manifest;
            const { function: _function, endpoint: _endpoint } = modules;
            this.checkUnsupportedModules(manifest.typedContent.modules, validationErrors, yamlContentByLine);
            _function === null || _function === void 0 ? void 0 : _function.forEach((f) => {
                if (f.key.length > 23) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.function.invalidKeyLength(f.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(f.key, yamlContentByLine)));
                }
            });
            if (Object.keys(modules).filter((moduleKey) => this.isNotFunctionOrEndpoint(moduleKey)).length < 1) {
                validationErrors.push(Object.assign({ message: text_1.errors.modules.missingModule(), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)('app', yamlContentByLine)));
            }
            const validModules = Object.keys(modules).filter((moduleKey) => this.isNotFunctionOrEndpoint(moduleKey));
            validModules.forEach((moduleKey) => {
                var _a;
                (_a = modules[moduleKey]) === null || _a === void 0 ? void 0 : _a.forEach((module) => {
                    (0, utils_1.findInvalidFunctionReferences)(module, _function).forEach((functionKey) => {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.wrongFunctionReference(moduleKey, functionKey), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(moduleKey, yamlContentByLine)));
                    });
                    (0, utils_1.findInvalidEndpointReferences)(module, _endpoint).forEach((endpointKey) => {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.wrongEndpointReference(moduleKey, endpointKey), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(moduleKey, yamlContentByLine)));
                    });
                });
            });
            this.endpointValidations(_endpoint, validationErrors, yamlContentByLine, remotes, (permissions === null || permissions === void 0 ? void 0 : permissions.scopes) || [], modules);
            const moduleKeys = [];
            Object.keys(modules).forEach((moduleKey) => {
                var _a;
                (_a = modules[moduleKey]) === null || _a === void 0 ? void 0 : _a.forEach((module) => moduleKeys.push(module.key));
            });
            const duplicateKeys = [...new Set(moduleKeys.filter((item, index) => moduleKeys.indexOf(item) != index))];
            duplicateKeys.forEach((duplicateKey) => {
                validationErrors.push(Object.assign({ message: text_1.errors.modules.duplicateKeyFound(duplicateKey), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(duplicateKey, yamlContentByLine)));
            });
            _function === null || _function === void 0 ? void 0 : _function.forEach((func) => {
                if (!this.functionHandlerRegex.test(func.handler)) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.function.handler.invalidRegex(func.handler, this.functionHandlerRegex), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(func.handler, yamlContentByLine)));
                }
                else {
                    const matches = this.functionHandlerRegex.exec(func.handler);
                    const fileName = matches ? matches[1] : undefined;
                    const _checkFileExists = (fileName) => {
                        return (['tsx', 'jsx', 'ts', 'js'].find((ext) => (0, fs_1.existsSync)((0, path_1.resolve)((0, path_1.dirname)(filePath), 'src', `${fileName}.${ext}`))) !== undefined);
                    };
                    if (!_checkFileExists(fileName)) {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.function.handler.fileNotExists(func.handler, fileName), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(func.handler, yamlContentByLine)));
                    }
                }
            });
            (_a = modules[types_1.AllModuleTypes.JiraWorkflowValidator]) === null || _a === void 0 ? void 0 : _a.forEach((module) => {
                if (!module.expression && !module.function) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.jiraWorkflowValidator.missingProperty(module.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                }
                if (module.expression && module.function) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.jiraWorkflowValidator.invalidProperty(module.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                }
            });
            (_b = modules[types_1.AllModuleTypes.JiraWorkflowCondition]) === null || _b === void 0 ? void 0 : _b.forEach((module) => {
                if (!(module.expression && module.expression.trim())) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.jiraWorkflowCondition.missingExpression(module.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                }
            });
            validationErrors.push(...(0, ui_modifications_1.validateUiModificationsModule)(modules, yamlContentByLine));
            validationErrors.push(...(0, validate_full_admin_page_1.validateFullAdminPage)(modules, yamlContentByLine));
            [types_1.AllModuleTypes.JiraProjectPage, types_1.AllModuleTypes.JiraProjectSettingsPage, types_1.AllModuleTypes.JiraGlobalPage].forEach((moduleType) => {
                const moduleArray = modules[moduleType];
                if (moduleArray && moduleArray.length > 1) {
                    validationErrors.push(Object.assign({ message: text_1.errors.modules.singleEntryOfTheModule(moduleType), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(moduleArray[1].key, yamlContentByLine)));
                }
                if (moduleArray && moduleArray.length === 1) {
                    validationErrors.push(...(0, validate_subpages_in_module_1.validateSubpagesInModule)(modules, moduleType, yamlContentByLine));
                }
            });
            [types_1.AllModuleTypes.JiraCustomField, types_1.AllModuleTypes.JiraCustomFieldType].forEach((moduleType) => {
                var _a;
                (_a = modules[moduleType]) === null || _a === void 0 ? void 0 : _a.forEach((module) => {
                    if (!module || module.type !== 'object' || !module.schema)
                        return;
                    const getAliases = (properties = {}) => Object.values(properties)
                        .map((v) => [v.searchAlias, ...getAliases(v.properties)])
                        .reduce((acc, val) => acc.concat(val), [])
                        .filter(Boolean);
                    const aliases = getAliases(module.schema.properties);
                    const duplicates = Array.from(new Set(aliases.filter((item, index) => aliases.indexOf(item) != index)));
                    if (duplicates.length) {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.customFields.searchAlias(duplicates), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                    }
                });
            });
            validationErrors.push(...(0, confluence_1.validateConfluenceModules)(modules, yamlContentByLine));
            (_c = modules === null || modules === void 0 ? void 0 : modules.trigger) === null || _c === void 0 ? void 0 : _c.forEach((module) => {
                if (module.filter) {
                    const onlyJiraEvents = module.events.every((e) => e.includes('jira'));
                    if (!onlyJiraEvents) {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.trigger.filteringWorksOnlyWithJiraEvents(), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(module.key, yamlContentByLine)));
                    }
                }
            });
        }
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
    isNotFunctionOrEndpoint(moduleKey) {
        return moduleKey !== (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction) && moduleKey !== (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreEndpoint);
    }
    checkUnsupportedModules(modules, validationErrors, yamlContentByLine) {
        Object.keys(modules)
            .filter((key) => !types_1.SUPPORTED_MODULES.map((key) => (0, utils_1.cleanKey)(key)).includes(key))
            .forEach((invalidKey) => {
            validationErrors.push(Object.assign({ message: text_1.errors.modules.invalidModule(invalidKey), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(invalidKey, yamlContentByLine)));
        });
    }
    connectModuleValidation(manifest, validationErrors) {
        var _a, _b;
        if (!((_a = manifest.typedContent) === null || _a === void 0 ? void 0 : _a.modules) && !((_b = manifest.typedContent) === null || _b === void 0 ? void 0 : _b.connectModules)) {
            validationErrors.push({
                message: text_1.errors.schemaError(undefined, [], text_1.errors.schema.oneOf([['modules'], ['connectModules']])),
                reference: text_1.References.SchemaError,
                level: 'error',
                line: 1,
                column: 0
            });
        }
    }
    endpointValidations(_endpoint, validationErrors, yamlContentByLine, remotes, scopes, modules) {
        var _a;
        const SYSTEM_TOKEN_SCOPE = 'read:app-system-token';
        const USER_TOKEN_SCOPE = 'read:app-user-token';
        const _checkRemoteExists = (remoteKey) => {
            return (remotes === null || remotes === void 0 ? void 0 : remotes.find((remote) => remote.key === remoteKey)) !== undefined;
        };
        const eventModulesWithEndpoint = ((_a = modules === null || modules === void 0 ? void 0 : modules.trigger) === null || _a === void 0 ? void 0 : _a.filter((trigger) => trigger.endpoint != null)) || [];
        eventModulesWithEndpoint.forEach((event) => {
            var _a, _b;
            const endpointModule = _endpoint === null || _endpoint === void 0 ? void 0 : _endpoint.find((remoteEndpoint) => remoteEndpoint.key === event.endpoint);
            if ((_b = (_a = endpointModule === null || endpointModule === void 0 ? void 0 : endpointModule.auth) === null || _a === void 0 ? void 0 : _a.appUserToken) === null || _b === void 0 ? void 0 : _b.enabled) {
                validationErrors.push(Object.assign({ message: text_1.errors.modules.trigger.endpointOnlySupportSystemToken(event.key, endpointModule.key), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(endpointModule.key, yamlContentByLine)));
            }
        });
        _endpoint === null || _endpoint === void 0 ? void 0 : _endpoint.forEach((endpoint) => {
            var _a, _b, _c, _d;
            if (!_checkRemoteExists(endpoint.remote)) {
                validationErrors.push(Object.assign({ message: text_1.errors.modules.endpoint.remote.notExists(endpoint.remote), reference: text_1.References.Modules, level: 'error' }, (0, utils_1.findPosition)(endpoint.remote, yamlContentByLine)));
            }
            if (((_b = (_a = endpoint.auth) === null || _a === void 0 ? void 0 : _a.appUserToken) === null || _b === void 0 ? void 0 : _b.enabled) && !scopes.includes(USER_TOKEN_SCOPE)) {
                validationErrors.push(Object.assign({ message: text_1.errors.permissions.missingEndpointPermissionFromScope(USER_TOKEN_SCOPE, endpoint.key), reference: text_1.References.MissingScopes, level: 'error', metadata: {
                        missingPermission: USER_TOKEN_SCOPE
                    } }, (0, utils_1.findPosition)('scopes', yamlContentByLine)));
            }
            if (((_d = (_c = endpoint.auth) === null || _c === void 0 ? void 0 : _c.appSystemToken) === null || _d === void 0 ? void 0 : _d.enabled) && !scopes.includes(SYSTEM_TOKEN_SCOPE)) {
                validationErrors.push(Object.assign({ message: text_1.errors.permissions.missingEndpointPermissionFromScope(SYSTEM_TOKEN_SCOPE, endpoint.key), reference: text_1.References.MissingScopes, level: 'error', metadata: {
                        missingPermission: SYSTEM_TOKEN_SCOPE
                    } }, (0, utils_1.findPosition)('scopes', yamlContentByLine)));
            }
        });
    }
}
exports.ModulesValidator = ModulesValidator;
