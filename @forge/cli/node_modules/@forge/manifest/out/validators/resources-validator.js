"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourcesValidator = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = require("path");
const cheerio_1 = tslib_1.__importDefault(require("cheerio"));
const utils_1 = require("../utils");
const text_1 = require("../text");
const utils_2 = require("../utils");
const MAX_RESOURCE_COUNT = 10;
class ResourcesValidator {
    async validate(manifest) {
        if (!manifest || !manifest.typedContent || !manifest.filePath) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        const validationErrors = [];
        const { typedContent: { resources, modules }, yamlContentByLine, filePath } = manifest;
        if (!resources) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        if (resources.length > MAX_RESOURCE_COUNT) {
            validationErrors.push(Object.assign({ message: text_1.errors.resources.tooManyResourcesError(MAX_RESOURCE_COUNT), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)('resource', yamlContentByLine)));
        }
        if (modules) {
            const resourceMap = new Map(resources.map(({ key, path }) => [key, path]));
            const manifestDir = (0, path_1.dirname)(filePath);
            (0, utils_1.getValidModules)(modules).forEach((moduleKey) => {
                var _a;
                (_a = modules[moduleKey]) === null || _a === void 0 ? void 0 : _a.forEach((module) => {
                    (0, utils_2.findInvalidResourceReferences)(module, resources).forEach((resourceKey) => {
                        validationErrors.push(Object.assign({ message: text_1.errors.modules.wrongResourceReference(moduleKey, resourceKey), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(moduleKey, yamlContentByLine)));
                    });
                    const resourcePath = resourceMap.get(module.resource);
                    if (resourcePath === undefined)
                        return;
                    const resourcePathDir = (0, path_1.resolve)(resourcePath);
                    if (module.render === 'native') {
                        if (fs_1.default.lstatSync(resourcePathDir).isDirectory()) {
                            validationErrors.push(Object.assign({ message: text_1.errors.modules.wrongResourceType(resourcePath), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(moduleKey, yamlContentByLine)));
                        }
                    }
                    else {
                        if (fs_1.default.lstatSync(resourcePathDir).isDirectory() &&
                            !fs_1.default.existsSync((0, path_1.resolve)(manifestDir, resourcePath, 'index.html'))) {
                            validationErrors.push(Object.assign({ message: text_1.errors.resources.missingEntrypoint(resourcePath, moduleKey), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(resourcePath, yamlContentByLine)));
                        }
                        else if (!fs_1.default.lstatSync(resourcePathDir).isDirectory()) {
                            validationErrors.push(Object.assign({ message: text_1.errors.resources.nonDirectory(resourcePath, moduleKey), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(resourcePath, yamlContentByLine)));
                        }
                    }
                });
            });
            (0, utils_1.getValidModules)(modules).forEach((moduleKey) => {
                const uniquePaths = new Set(modules[moduleKey].map(({ resource }) => resourceMap.get(resource)));
                uniquePaths.forEach((path) => {
                    var _a, _b, _c;
                    if (!path)
                        return;
                    if (fs_1.default.existsSync((0, path_1.resolve)(manifestDir, path, 'index.html'))) {
                        const content = fs_1.default.readFileSync((0, path_1.resolve)(manifestDir, path, 'index.html'));
                        const $ = cheerio_1.default.load(content);
                        const cspContent = $('meta[http-equiv="Content-Security-Policy"]').attr('content');
                        if (cspContent) {
                            const cspStyleSrc = cspContent.split(';').find((s) => s.startsWith('style-src'));
                            if (cspStyleSrc === null || cspStyleSrc === void 0 ? void 0 : cspStyleSrc.includes("'unsafe-inline'")) {
                                const existingStylesPermissions = (_c = (_b = (_a = manifest.typedContent) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.styles;
                                let shouldShowError = false;
                                if (!(existingStylesPermissions === null || existingStylesPermissions === void 0 ? void 0 : existingStylesPermissions.length) || !(existingStylesPermissions === null || existingStylesPermissions === void 0 ? void 0 : existingStylesPermissions.includes('unsafe-inline'))) {
                                    shouldShowError = true;
                                }
                                if (shouldShowError) {
                                    validationErrors.push(Object.assign({ message: text_1.errors.resources.deprecatedCspPolicyDefinition(path), reference: text_1.References.Resources, level: 'error', metadata: {
                                            missingContentStylePermission: 'unsafe-inline'
                                        } }, (0, utils_1.findPosition)(path, yamlContentByLine)));
                                }
                            }
                        }
                    }
                });
            });
        }
        const invalidDirectoryErrors = resources
            .map((resource) => {
            const { key, path } = resource;
            const manifestDir = (0, path_1.dirname)(filePath);
            const resourceDirPath = (0, path_1.resolve)(manifestDir, path);
            if (!fs_1.default.existsSync(resourceDirPath)) {
                return Object.assign({ message: text_1.errors.resources.missingResource(path, key), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(path, yamlContentByLine));
            }
            else if (fs_1.default.lstatSync(resourceDirPath).isDirectory() && fs_1.default.readdirSync(resourceDirPath).length === 0) {
                return Object.assign({ message: text_1.errors.resources.emptyDirectory(path, key), reference: text_1.References.Resources, level: 'error' }, (0, utils_1.findPosition)(path, yamlContentByLine));
            }
        })
            .filter((error) => error !== undefined);
        validationErrors.push(...invalidDirectoryErrors);
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
}
exports.ResourcesValidator = ResourcesValidator;
