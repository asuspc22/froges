"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.References = exports.errors = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
exports.errors = {
    invalidManifest: (reason) => `manifest.yml failed to parse content - ${reason}`,
    missingManifest: () => `To run this command, make sure you're in the top-level directory of your app, and the manifest.yml file is in the same directory.`,
    schemaError: (value, path, reason) => {
        if (value) {
            return `${path.join(' ')} '${value}' ${reason}`;
        }
        return `${path.length === 0 ? 'document' : path.join(' ')} ${reason}`;
    },
    schema: {
        oneOf: (props) => props
            ? `required properties are ${props.map((v) => "'" + v.join(', ') + "'").join(' or ')}`
            : 'provided properties do not match schema. Learn more about modules at https://go.atlassian.com/forge-modules.',
        enumValues: (props) => `allowed values are ${props.map((v) => "'" + v + "'").join(', ')}`,
        deprecatedValue: (section, field, additionalInfo) => `The "${field}" property under "${section}" is deprecated and can be removed. ${additionalInfo ? `${additionalInfo}` : ''}`,
        additionalProperties: (additionalProperty) => `should NOT have additional property '${additionalProperty}'`,
        notAllowed: (props) => props
            ? `does not support the following Forge properties - ${props.map((v) => "'" + v + "'").join(', ')}`
            : 'provided properties do not match schema. Learn more about modules at https://go.atlassian.com/forge-modules'
    },
    permissions: {
        invalidPermission: (element, value) => `Invalid '${element}' permission in the manifest.yml file - '${value}'. Learn more about permissions at: https://go.atlassian.com/forge-permissions.`,
        missingPermissionFromScope: (scope, event) => `Trigger event: '${event}' requires '${scope}' scope`,
        missingEndpointPermissionFromScope: (scope, key) => `Endpoint module: '${key}' requires '${scope}' scope.`,
        deprecatedPermission: (element, value) => `There are deprecated scopes '${element}' in the manifest.yml file: '${value.join(', ')}'. You need to update this app to use new scopes and remove the deprecated scopes. Learn more at: https://go.atlassian.com/forge-permissions.`
    },
    connectModules: {
        invalidConnectModule: (module) => `invalid value '${module}' in connectModules`,
        missingConnectModule: () => `document must have at least 1 valid connect module when 'connectModules' is declared`,
        duplicateKeyFound: (key) => `found duplicate connect module key '${key}'`,
        duplicatateLifecycleFound: (module) => `'${module}' should contain only one element`
    },
    modules: {
        invalidModule: (module) => `invalid value '${module}' in modules`,
        missingModule: () => 'document must have at least 1 module',
        missingFunction: () => 'document must have at least 1 function',
        duplicateKeyFound: (key) => `found duplicate module key '${key}'`,
        wrongFunctionReference: (module, functionKey) => `${module} references undefined function module with key '${functionKey}'`,
        wrongEndpointReference: (module, endpointKey) => `${module} references undefined endpoint module with key '${endpointKey}'`,
        wrongResourceReference: (module, resourceKey) => `missing resource key '${resourceKey}' is being referenced by ${module} module`,
        wrongResourceType: (folder) => `Client Side UI Kit resource (${folder}) cannot be a directory`,
        singleEntryOfTheModule: (moduleType) => `Only a single entry of the ${moduleType} module can be defined in the manifest`,
        singleEntryOfModuleWithoutConfigureAndStartedParams: (moduleType) => `The ${moduleType} module can only have a single entry that doesn’t include either useAsConfig or useAsGetStarted properties.`,
        singleEntryOfModuleWithConfigureParam: (moduleType) => `The ${moduleType} module can only have a single entry that includes the useAsConfig property.`,
        singleEntryOfModuleWithGetStartedParam: (moduleType) => `The ${moduleType} module can only have a single entry that includes the useAsGetStarted property.`,
        displayConditions: {
            overcomplicated: (moduleKey) => `Nesting of display conditions of the "${moduleKey}" module exceeds 10 levels.`,
            invalid: (moduleKey) => `Display conditions of the "${moduleKey}" module are invalid.`,
            propertyNotAllowed: (moduleKey, propertyName) => `Display conditions of the "${moduleKey}" module are invalid. "${propertyName}" property is not allowed.`,
            typeMismatch: (moduleKey, propertyName, errorDetails) => `Display conditions of the "${moduleKey}" module are invalid. "${propertyName}" property ${errorDetails}.`
        },
        confluence: {
            multipleProperty: (property, moduleKey, keys) => `There can be only 1 ${moduleKey} module which designates "${property}": true. Modules containing designation: ${keys.join(', ')}`,
            propertyUniqueness: (property, moduleKey, keys) => `${property} should be unique across all ${moduleKey} modules. Found duplicates: ${keys.join(', ')}`,
            crossModulePropertyUniqueness: (property, keys) => `${property} should be unique across all modules. Found duplicates: ${keys.join(', ')}`,
            validateCustomContentHierarchyUnknown: (property, moduleKey, unknownKey) => `${property} of the "${moduleKey}" module refers to unknown key: ${unknownKey}`,
            validateCustomContentCrossReferenceMissingContainer: (moduleKey, referredModuleKey) => `supportedContainerTypes of the "${moduleKey}" module refers to "${referredModuleKey}" module. "${referredModuleKey}" module must include "${moduleKey}" in supportedChildTypes`,
            validateCustomContentCrossReferenceMissingChild: (moduleKey, referredModuleKey) => `supportedChildTypes of the "${moduleKey}" module refers to "${referredModuleKey}" module. "${referredModuleKey}" module must include "${moduleKey}" in supportedContainerTypes`,
            keyboardShortcuts: {
                emptyAccelerator: () => 'Keyboard shortcut accelerator must be defined and not be an empty string.',
                spaceAroundAccelerator: (accelerator) => `Keyboard shortcut accelerator must not have surrounding empty spaces. Accelerator issue found: [${accelerator}]`,
                invalidPlusSyntax: (accelerator) => `Keyboard shortcut accelerator must not be single "+" character or have empty spaces on left or right of "+" character. Accelerator issue found: [${accelerator}]`,
                combinationKeysAreNotUnique: (accelerator) => `Keyboard shortcut accelerator combinations must have unique keys when joined with "+". Accelerator issue found: [${accelerator}]`,
                invalidKey: (accelerator, key) => `Keyboard shortcut accelerator key must be a valid named key, i.e. ctrl, command, or a single key. Accelerator issue found: [${accelerator}] with invalid key: [${key}]`,
                moreThanOneNonModifierKey: (accelerator) => `Keyboard shortcut accelerator combination is invalid. A valid accelerator combination should have a single key or a single key preceeded with one or more modifiers, i.e. ctrl, shift, command. Accelerator issue found: [${accelerator}]`,
                modifierKeysShouldPrecedeNonModifierKey: (accelerator) => `Keyboard shortcut accelerator modifier keys should precede the key being modified. Instead of "a+ctrl", one should specify the accelerator as "ctrl+a". Accelerator issue found: [${accelerator}]`
            }
        },
        jiraWorkflowValidator: {
            missingProperty: (key) => `${types_1.AllModuleTypes.JiraWorkflowValidator} module '${key}' must have either a function or expression.`,
            invalidProperty: (key) => `${types_1.AllModuleTypes.JiraWorkflowValidator} module '${key}' can only have either a function or expression`
        },
        jiraWorkflowCondition: {
            missingExpression: (key) => `${types_1.AllModuleTypes.JiraWorkflowCondition} module '${key}' must have a non-blank expression.`
        },
        jiraEntityProperty: {
            maxExtractionsPerApp: (limit) => `All ${types_1.AllModuleTypes.JiraEntityProperty} modules combined cannot declare more than ${limit} values.`
        },
        customFields: {
            searchAlias: (aliases) => `Search alias should be always unique per field. Found duplicates: ${aliases.join(', ')}.`
        },
        subPages: {
            invalidPagesAndSectionsForConfigurePages: (key) => `You can’t use either pages or sections in the ${key} entry that includes either useAsConfig or useAsGetStarted properties.`,
            subPagesWithUIKit: (key) => `Subpages in UI kit are not supported. Use Custom UI in the '${key}' module instead.`,
            invalidPagesAndSections: (key) => `'pages' cannot be used with 'sections' in the module '${key}'.`
        },
        function: {
            invalidKeyLength: (key) => `The function key exceeds 23 characters: ‘${key}’.`,
            handler: {
                invalidRegex: (key, regex) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction)} handler property '${key}' must be in format <module>.<function> (example: index.run).`,
                fileNotExists: (key, fileName) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction)} handler property '${key}' cannot find associated file with name '${fileName}.[jt](s|sx)'`
            }
        },
        endpoint: {
            remote: {
                notExists: (key) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreEndpoint)} remote property '${key}' was not found.`
            }
        },
        trigger: {
            filteringWorksOnlyWithJiraEvents: () => `Trigger filtering works only with Jira events`,
            endpointOnlySupportSystemToken: (productEventKey, endpointModuleKey) => `Trigger module: '${productEventKey}' using remote endpoint: '${endpointModuleKey}' only supports appSystemToken. Update appUserToken to false.`
        }
    },
    resources: {
        missingResource: (folder, key) => `missing resource '${folder}' is being referenced by '${key}' in resources`,
        emptyDirectory: (folder, key) => `empty directory '${folder}' is being referenced by '${key}' in resources`,
        missingEntrypoint: (folder, key) => `missing index.html file in directory (${folder}) is being referenced by a Custom UI resource in ${key} module`,
        deprecatedCspPolicyDefinition: (folder) => `The index.html file in the (${folder}) directory is using a deprecated method of defining CSP. To use the supported method, go to: https://go.atlassian.com/forge-content-security-and-egress-controls`,
        tooManyResourcesError: (limit) => `document exceeds ${limit} resources`,
        nonDirectory: (folder, key) => `Custom UI resource must be a directory. (${folder}) in ${key} module is not a directory`
    },
    deprecationInfo: {
        app: {
            name: 'You can now manage this in the Developer Console at https://developer.atlassian.com/console/.'
        }
    },
    providers: {
        missingRemote: (provider, remote) => `missing remote '${remote}' is being referenced by '${provider}' in providers`,
        missingEgress: (remote) => `missing egress permissions for remote '${remote}'. Please add the remote to permissions.fetch`,
        missingProfileFunction: (provider, functionKey) => `missing function '${functionKey}' is being referenced by '${provider}' in providers`
    },
    app: {
        missingAppConnectRemote: () => `missing app.connect.remote. app.connect.remote is required if connectModules are present.`,
        missingRemoteForConnect: (key) => `no remote found with key '${key}' matching app.connect.remote value.`,
        missingConnectModules: () => 'Missing connectModules. When app.connect.authentication is present, connectModules is required.',
        storage: {
            missingStorageInformation: () => 'Missing storage configuration. When app.storage is present, either entities or classifications is required.',
            entities: {
                entityNameTooLong: (entity, limit) => `Entity name '${entity}' exceeds maximum allowed length of ${limit} characters.`,
                missingAttributes: (entity) => `Entity '${entity}' must contain at least one attribute.`,
                tooManyAttributes: (entity, limit) => `Entity '${entity}' contains more attributes than the allowed limit of ${limit}.`,
                attributeNameTooLong: (entity, attribute, limit) => `Entity '${entity}' attribute name '${attribute}' exceeds maximum allowed length of ${limit}.`,
                tooManyIndexes: (entity, limit) => `Entity '${entity}' contains more indexes than the allowed limit of ${limit}.`,
                invalidIndexRange: (entity, index) => `Entity '${entity}' index '${index}' must refer to a valid attribute of the entity.`,
                invalidIndexPartition: (entity, partition) => `Entity '${entity}' index partition '${partition}' must refer to a valid attribute of the entity.`,
                reservedIndexName: (entity, index) => `Entity '${entity}' cannot use reserved index name '${index}'.`
            }
        }
    }
};
var References;
(function (References) {
    References["MissingManifest"] = "manifest-file-required";
    References["InvalidManifest"] = "valid-yaml-required";
    References["SchemaError"] = "valid-document-required";
    References["Permissions"] = "valid-permissions-required";
    References["MissingScopes"] = "permission-scope-required";
    References["Modules"] = "valid-module-required";
    References["ConnectModules"] = "valid-connect-module-required";
    References["DuplicateModuleKeys"] = "duplicate-module-keys";
    References["Resources"] = "valid-resource-required";
    References["Providers"] = "valid-provider-required";
    References["Deprecated"] = "deprecated-property";
    References["App"] = "valid-app-config-required";
})(References = exports.References || (exports.References = {}));
