"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandboxRuntimeAPI = exports.getNodeRuntimeAPI = exports.createProxyFetch = exports.getRedirectUrl = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importStar(require("node-fetch"));
const _1 = require(".");
const runtime_1 = require("./runtime");
const polyfill_response_1 = require("./polyfill-response");
const errors_1 = require("./errors");
const perf_hooks_1 = require("perf_hooks");
const FORGE_PROXY_UPSTREAM_LATENCY_HEADER = 'forge-proxy-upstream-latency';
const ATLASSIAN_TOKEN_SERVICE_KEY = 'atlassian-token-service-key';
const providerToMetric = {
    app: 'asApp',
    user: 'asUser'
};
const remoteToMetric = {
    jira: 'requestJira',
    confluence: 'requestConfluence',
    bitbucket: 'requestBitbucket',
    stargate: 'requestAtlassian'
};
const metricName = (args) => {
    switch (args.type) {
        case 'egress':
            return 'api.fetch';
        case 'fpp':
            if (args.provider === 'none') {
                return `api.${remoteToMetric[args.remote]}`;
            }
            return `api.${providerToMetric[args.provider]}.${remoteToMetric[args.remote]}`;
    }
};
const createProxyRequest = ({ url: proxyUrl, token, host }, args, originalRequest) => {
    let proxyEndpoint;
    switch (args.type) {
        case 'egress':
            proxyEndpoint = `${proxyUrl}/egress`;
            break;
        case 'fpp':
            proxyEndpoint = `${proxyUrl}/fpp/provider/${args.provider}/remote/${args.remote}`;
            break;
    }
    const tempRequest = new node_fetch_1.Request(proxyEndpoint, originalRequest);
    const proxyRequest = new node_fetch_1.Request(tempRequest, { redirect: 'manual' });
    proxyRequest.headers.set('Forge-Proxy-Target', originalRequest.url);
    proxyRequest.headers.set('Forge-Proxy-Authorization', `Bearer ${token}`);
    if (host) {
        proxyRequest.headers.set('Host', host);
    }
    return proxyRequest;
};
const wrapWithOverheadMetric = async (fetch, metrics) => {
    const requestStart = perf_hooks_1.performance.now();
    const response = await fetch;
    const requestEnd = perf_hooks_1.performance.now();
    const proxyUpstreamLatency = parseInt(response.headers.get(FORGE_PROXY_UPSTREAM_LATENCY_HEADER) || '');
    if (proxyUpstreamLatency) {
        metrics.timing('proxy-success-overhead').set(requestEnd - requestStart - proxyUpstreamLatency);
    }
    return response;
};
const getRedirectArgs = (args, response) => {
    const proxyRelativeLocation = response.headers.get('forge-proxy-relative-location');
    if (!proxyRelativeLocation) {
        return { type: 'egress' };
    }
    return args;
};
const buildGetRequest = (url, originalRequest) => {
    const request = new node_fetch_1.Request(url, { method: 'GET' });
    for (const [name, values] of Array.from(originalRequest.headers.entries())) {
        if (!name.toLowerCase().startsWith('content-')) {
            request.headers.set(name, values);
        }
    }
    return request;
};
const getLocation = (responseHeaders) => {
    const location = responseHeaders.get('location');
    if (!location) {
        throw new errors_1.FetchError('Redirect location is empty');
    }
    return location;
};
const getRedirectUrl = (responseHeaders, original, isFromEgress) => {
    if (!isFromEgress) {
        return responseHeaders.get('forge-proxy-relative-location') || getLocation(responseHeaders);
    }
    return new URL(getLocation(responseHeaders), original).toString();
};
exports.getRedirectUrl = getRedirectUrl;
const buildRedirectedRequest = (response, originalRequest, isFromEgress) => {
    const url = (0, exports.getRedirectUrl)(response.headers, originalRequest.url, isFromEgress);
    if (response.status === 303) {
        return buildGetRequest(url, originalRequest);
    }
    return new node_fetch_1.Request(url, originalRequest);
};
const fetchViaProxy = async ({ proxy, proxyFetchArgs, request, metrics, count = 0 }) => {
    const REDIRECT_STATUS = [300, 301, 302, 303, 307, 308];
    const MAX_REDIRECTS = 20;
    if (count >= MAX_REDIRECTS) {
        throw new errors_1.FetchError('Max redirects exceeded');
    }
    const proxyRequest = createProxyRequest(proxy, proxyFetchArgs, request);
    if (request.redirect === 'manual' && count === 0) {
        return wrapWithOverheadMetric((0, node_fetch_1.default)(proxyRequest), metrics);
    }
    const response = await wrapWithOverheadMetric((0, node_fetch_1.default)(proxyRequest), metrics);
    if (REDIRECT_STATUS.includes(response.status)) {
        const redirectedRequest = buildRedirectedRequest(response, request, proxyFetchArgs.type === 'egress');
        const redirectedArgs = getRedirectArgs(proxyFetchArgs, response);
        return fetchViaProxy({
            proxy,
            proxyFetchArgs: redirectedArgs,
            request: redirectedRequest,
            metrics,
            count: count + 1
        });
    }
    return response;
};
const handleProxyResponseErrors = (response, requestUrl) => {
    if (response.headers.has('forge-proxy-error')) {
        const errorReason = response.headers.get('forge-proxy-error');
        if (errorReason === 'NEEDS_AUTHENTICATION_ERR') {
            throw new errors_1.NeedsAuthenticationError('Authentication Required', ATLASSIAN_TOKEN_SERVICE_KEY);
        }
        if (errorReason === 'BLOCKED_EGRESS') {
            throw new errors_1.ExternalEndpointNotAllowedError(requestUrl);
        }
        throw new errors_1.ProxyRequestError(response.status, response.headers.get('forge-proxy-error'));
    }
};
const createProxyFetch = (args) => (0, runtime_1.wrapInMetrics)(metricName(args), async (url, options) => {
    const { proxy, metrics } = (0, runtime_1.getRuntime)();
    const response = await fetchViaProxy({
        proxy,
        proxyFetchArgs: args,
        request: new node_fetch_1.Request(url, options),
        metrics
    });
    handleProxyResponseErrors(response, url.toString());
    return response;
}, { tags: { proxy: 'true' } });
exports.createProxyFetch = createProxyFetch;
const throwNotImplementedError = () => {
    throw new Error('not implemented');
};
function getNodeRuntimeAPI() {
    return {
        fetch: (0, _1.wrapWithRouteUnwrapper)((0, exports.createProxyFetch)({ type: 'egress' })),
        requestJira: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'none', remote: 'jira' })),
        requestConfluence: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'none', remote: 'confluence' })),
        requestBitbucket: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'none', remote: 'bitbucket' })),
        asUser: () => ({
            requestJira: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'user', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'user', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'user', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'user', remote: 'stargate' })),
            withProvider: throwNotImplementedError
        }),
        asApp: () => ({
            requestJira: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'app', remote: 'jira' })),
            requestConfluence: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'app', remote: 'confluence' })),
            requestBitbucket: (0, _1.wrapRequestProduct)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'app', remote: 'bitbucket' })),
            requestGraph: (0, _1.wrapRequestGraph)((0, exports.createProxyFetch)({ type: 'fpp', provider: 'app', remote: 'stargate' }))
        })
    };
}
exports.getNodeRuntimeAPI = getNodeRuntimeAPI;
function getSandboxRuntimeAPI(api) {
    return (0, _1.wrapFetchApiMethods)(api, polyfill_response_1.transformResponse);
}
exports.getSandboxRuntimeAPI = getSandboxRuntimeAPI;
