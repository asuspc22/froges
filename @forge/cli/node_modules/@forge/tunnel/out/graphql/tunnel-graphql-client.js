"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelGraphqlClient = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const cli_shared_2 = require("@forge/cli-shared");
class CreateAppTunnelError extends cli_shared_1.GraphQlMutationError {
    constructor(message, { requestId, code, statusCode }) {
        super(cli_shared_2.Text.tunnel.error.create(message), { requestId, code, statusCode });
    }
}
class DeleteAppTunnelError extends cli_shared_1.GraphQlMutationError {
    constructor(message, { requestId, code, statusCode }) {
        super(cli_shared_2.Text.tunnel.error.delete(message), { requestId, code, statusCode });
    }
}
class TunnelGraphqlClient {
    constructor(graphqlClient) {
        this.graphqlClient = graphqlClient;
    }
    async createAppTunnels(appId, environmentKey, tunnelDefinitions) {
        const mutation = `
      mutation forge_cli_createApplicationTunnels($input: CreateAppTunnelsInput!) {
        createAppTunnels(input: $input) {
          success
          errors {
            message
            extensions {
              errorType
            }
          }
          keepAlive
        }
      }
    `;
        const { response: { createAppTunnels: { success, errors, keepAlive } }, requestId } = await this.graphqlClient.mutate(mutation, {
            input: {
                appId,
                environmentKey,
                tunnelDefinitions,
                force: true
            }
        });
        const error = (0, cli_shared_1.getError)(errors);
        if (!success) {
            throw new CreateAppTunnelError(`${error.message} (requestId: ${requestId || 'unknown'})`, {
                requestId,
                code: error.code,
                statusCode: error.statusCode
            });
        }
        return keepAlive;
    }
    async deleteTunnels(appId, environmentKey) {
        const mutation = `
      mutation forge_cli_deleteApplicationTunnels($input: DeleteAppTunnelInput!) {
        deleteAppTunnels(input: $input) {
          success
          errors {
            message
            extensions {
              errorType
            }
          }
        }
      }
    `;
        const { response: { deleteAppTunnels: { success, errors } }, requestId } = await this.graphqlClient.mutate(mutation, {
            input: {
                appId,
                environmentKey
            }
        });
        const error = (0, cli_shared_1.getError)(errors);
        if (!success) {
            throw new DeleteAppTunnelError(`${error.message} (requestId: ${requestId || 'unknown'})`, {
                requestId,
                code: error.code,
                statusCode: error.statusCode
            });
        }
    }
}
exports.TunnelGraphqlClient = TunnelGraphqlClient;
