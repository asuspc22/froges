"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalDevelopmentServer = exports.stopServer = void 0;
const tslib_1 = require("tslib");
const express_1 = tslib_1.__importDefault(require("express"));
const bundler_1 = require("@forge/bundler");
const cli_shared_1 = require("@forge/cli-shared");
const runtime_1 = require("@forge/runtime");
const __1 = require("../");
const util_1 = require("../util");
const bundler_2 = require("@forge/bundler");
async function stopServer(server) {
    if (!server) {
        return;
    }
    return new Promise((resolve) => {
        server.close(() => resolve());
    });
}
exports.stopServer = stopServer;
class LocalDevelopmentServer {
    constructor(invocationService, logger, configFile) {
        this.invocationService = invocationService;
        this.logger = logger;
        this.configFile = configFile;
        this.handleInvocation = async (req, res) => {
            var _a, _b, _c, _d, _e, _f;
            const request = req.body;
            const envVars = (0, runtime_1.getUserVars)();
            (_a = request.variables) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
                if (!envVars.find((i) => i.key === item.key)) {
                    envVars.push(item);
                }
            });
            request.variables = [...envVars].sort((a, b) => a.key.localeCompare(b.key));
            const allowList = (_f = (_e = (_d = (_c = (_b = this.permissions) === null || _b === void 0 ? void 0 : _b.external) === null || _c === void 0 ? void 0 : _c.fetch) === null || _d === void 0 ? void 0 : _d.backend) === null || _e === void 0 ? void 0 : _e.map((item) => {
                var _a, _b;
                if (typeof item === 'string')
                    return item;
                return (_b = (_a = this.remotes) === null || _a === void 0 ? void 0 : _a.find((remote) => remote.key === item.remote)) === null || _b === void 0 ? void 0 : _b.baseUrl;
            }).filter((item) => typeof item === 'string')) !== null && _f !== void 0 ? _f : undefined;
            request._meta = Object.assign(Object.assign({}, request._meta), { fetchAllowList: allowList });
            try {
                const invokeResults = await this.invocationService.invoke(request.handler, request);
                if ((await this.configFile.runtimeType()) === cli_shared_1.RuntimeType.nodejs && !invokeResults.success) {
                    return res.status(500).send(invokeResults.error);
                }
                res.json(invokeResults);
            }
            catch (error) {
                try {
                    res.status(500).send((0, util_1.toLambdaError)(error));
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
        };
        this.app = (0, express_1.default)();
        this.app.use(express_1.default.json({ limit: '6mb' }));
        this.app.post(`/:fnKey`, this.handleInvocation);
    }
    async start(port = 0, permissions, remotes) {
        this.permissions = permissions;
        this.remotes = remotes;
        this.httpServer = await new Promise((resolve, reject) => {
            const httpServer = this.app.listen({ port });
            httpServer.on('error', reject).on('listening', () => resolve(httpServer));
        });
        return {
            port: this.httpServer.address().port,
            devServer: this
        };
    }
    async stop() {
        await stopServer(this.httpServer);
    }
    async compileAndWatch({ onBuildWillStart, onBuildFinished }) {
        const handlers = await this.configFile.getAppHandlers();
        const entryPoints = (0, bundler_1.getEntryPoints)(handlers);
        if (!entryPoints.length) {
            return;
        }
        const getConfig = (await this.configFile.runtimeType()) === cli_shared_1.RuntimeType.nodejs
            ? bundler_2.getNodeRuntimeBuildConfig
            : bundler_2.getSandboxedRuntimeBuildConfig;
        const config = getConfig(entryPoints, {
            isWatchMode: true,
            isDebugMode: (0, __1.isInspectorEnabled)(),
            appDirectory: process.cwd()
        });
        const compiler = (0, bundler_2.getCompiler)(config);
        let isFirstRun = true;
        compiler.hooks.watchRun.tapAsync('watchRun', async (_, watchRunCallback) => {
            if (!isFirstRun) {
                await onBuildWillStart();
            }
            watchRunCallback();
        });
        return new Promise((resolve, reject) => {
            compiler.watch({ poll: 1000 }, async (compilerError, stats) => {
                try {
                    (0, bundler_2.handleWebpackCompilationResult)(this.logger, compilerError, stats);
                    this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.functionsBundlingSucceeded));
                    const bundle = (0, bundler_2.getInMemoryBundle)(config);
                    if (!isFirstRun) {
                        await onBuildFinished(null, bundle);
                    }
                    isFirstRun = false;
                    resolve(bundle);
                }
                catch (err) {
                    await onBuildFinished(err);
                    isFirstRun = false;
                    reject(err);
                }
            });
        });
    }
    getApp() {
        return this.app;
    }
}
exports.LocalDevelopmentServer = LocalDevelopmentServer;
