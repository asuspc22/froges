"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomUITunnelServer = void 0;
const tslib_1 = require("tslib");
const url_1 = require("url");
const express_1 = tslib_1.__importDefault(require("express"));
const http_proxy_middleware_1 = require("http-proxy-middleware");
const resource_tunnel_server_1 = require("./resource-tunnel-server");
const cli_shared_1 = require("@forge/cli-shared");
const dev_server_1 = require("./dev-server");
var ConnectionErrorCode;
(function (ConnectionErrorCode) {
    ConnectionErrorCode["REFUSED"] = "ECONNREFUSED";
})(ConnectionErrorCode || (ConnectionErrorCode = {}));
class CustomUITunnelServer extends resource_tunnel_server_1.ResourceTunnelServer {
    constructor(tunnelArgs) {
        super(tunnelArgs);
        this.tunnelArgs = tunnelArgs;
        const { tunnel, permissions, remotes } = tunnelArgs;
        this.app = (0, express_1.default)();
        this.app.use(this.getCustomUIHtmlTransformMiddleware(permissions, remotes));
        if (tunnel) {
            const { port: tunnelPort } = tunnel;
            this.proxy = (0, http_proxy_middleware_1.createProxyMiddleware)({
                target: `http://${this.tunnelArgs.host}:${tunnelPort}`,
                ws: true,
                logLevel: 'info',
                logProvider: () => {
                    return {
                        log: this.logger.trace,
                        debug: this.logger.trace,
                        info: this.logger.trace,
                        warn: this.logger.warn,
                        error: this.logger.error
                    };
                },
                onError: (err, req, res) => {
                    this.handleProxyDestinationNotStarted(err, req.url, res, tunnelPort);
                },
                onProxyReq: (_proxyReq, req) => {
                    this.logFileServed(req.url, (input) => cli_shared_1.Text.tunnel.customUI.fileProxied(input, this.key, tunnelPort));
                }
            });
            this.app.use('/', this.proxy);
        }
        else {
            this.app.use((req, _res, next) => {
                this.logFileServed(req.url, (input) => cli_shared_1.Text.tunnel.customUI.fileServed(input, this.key));
                next();
            });
            this.app.use(express_1.default.static(this.path));
        }
    }
    async start() {
        return new Promise((resolve) => {
            const { key, port } = this.tunnelArgs;
            const result = {
                port,
                devServer: this,
                resourceKey: key,
                tunnelUrl: new url_1.URL(`http://localhost:${port}`)
            };
            this.server = this.app.listen(this.port, () => resolve(result));
            this.server.on('upgrade', (req, socket, head) => this.handleWebsocketUpgrade(req, socket, head));
        });
    }
    async stop() {
        if (this.socket) {
            this.socket.end();
        }
        await (0, dev_server_1.stopServer)(this.server);
    }
    async compileAndWatch() {
        return {};
    }
    getApp() {
        return this.app;
    }
    handleProxyDestinationNotStarted(err, reqUrl, res, tunnelPort) {
        if ((err === null || err === void 0 ? void 0 : err.code) !== ConnectionErrorCode.REFUSED || (reqUrl !== '/' && reqUrl !== 'index.html')) {
            this.logger.error(err);
            return;
        }
        res.writeHead(500, {
            'Content-Type': 'text/plain'
        });
        this.logger.error(new Error(cli_shared_1.Text.tunnel.error.serverNotStartedOnPort(tunnelPort)));
        res.end(cli_shared_1.Text.tunnel.error.serverNotStartedOnPort(tunnelPort));
    }
    handleWebsocketUpgrade(req, socket, head) {
        var _a;
        this.socket = socket;
        if ((_a = this.proxy) === null || _a === void 0 ? void 0 : _a.upgrade) {
            return this.proxy.upgrade(req, socket, head);
        }
    }
}
exports.CustomUITunnelServer = CustomUITunnelServer;
