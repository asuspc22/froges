"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceTunnelServer = void 0;
const cli_shared_1 = require("@forge/cli-shared");
const csp_1 = require("@forge/csp");
const express_intercept_1 = require("express-intercept");
class ResourceTunnelServer {
    constructor({ port, key, path, cspReporterServerPort, logger }) {
        this.getCspHeader = (existingCsp) => new csp_1.CSPInjectionService()
            .getInjectableCSP(existingCsp, (0, cli_shared_1.getEnvironment)(cli_shared_1.CDNEnvironments), `http://localhost:${this.cspReporterServerPort}`)
            .join('; ');
        this.injectGlobalBridgeScript = (htmlContent) => new cli_shared_1.BridgeScriptService().injectBridgeCore(htmlContent, () => {
            throw new Error('Malformed HTML document');
        });
        this.injectIframeResizerScript = (htmlContent) => new cli_shared_1.IframeResizerScriptService().injectIframeResizer(htmlContent, () => {
            throw new Error('Malformed HTML document');
        });
        this.getCustomUIHtmlTransformMiddleware = (permissions, remotes) => (0, express_intercept_1.responseHandler)()
            .if((res) => /html/i.test(res.get('content-type')))
            .replaceBuffer((body, _, res) => {
            if (!res)
                return body;
            const htmlContentWithIframeResizerScript = this.injectIframeResizerScript(body);
            const htmlContentWithBridgeScript = this.injectGlobalBridgeScript(htmlContentWithIframeResizerScript);
            const cspDetails = new csp_1.CSPProcessingService({ info: () => { } }).getCspDetails(htmlContentWithBridgeScript, ResourceTunnelServer.transformPermissionsWithRemotes(permissions, remotes));
            res.setHeader('Content-Security-Policy', this.getCspHeader(cspDetails));
            return htmlContentWithBridgeScript;
        });
        this.port = port;
        this.key = key;
        this.path = path;
        this.logger = logger;
        this.cspReporterServerPort = cspReporterServerPort;
    }
    static transformPermissionsWithRemotes(permissions, remotes) {
        var _a, _b, _c, _d, _e;
        const client = (_d = (_c = (_b = (_a = permissions.external) === null || _a === void 0 ? void 0 : _a.fetch) === null || _b === void 0 ? void 0 : _b.client) === null || _c === void 0 ? void 0 : _c.map((item) => {
            var _a;
            if (typeof item === 'string')
                return item;
            return (_a = remotes === null || remotes === void 0 ? void 0 : remotes.find((remote) => remote.key === item.remote)) === null || _a === void 0 ? void 0 : _a.baseUrl;
        }).filter((item) => typeof item === 'string')) !== null && _d !== void 0 ? _d : undefined;
        return Object.assign(Object.assign({}, permissions), { external: Object.assign(Object.assign({}, permissions.external), { fetch: Object.assign(Object.assign({}, (_e = permissions.external) === null || _e === void 0 ? void 0 : _e.fetch), { client }) }) });
    }
    logFileServed(reqUrl, textDecorator) {
        if (reqUrl !== '/' && reqUrl !== '/index.html')
            return;
        this.logger.info(cli_shared_1.LogColor.trace(textDecorator('index.html')));
    }
}
exports.ResourceTunnelServer = ResourceTunnelServer;
