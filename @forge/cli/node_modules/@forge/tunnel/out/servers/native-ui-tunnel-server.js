"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeUITunnelServer = void 0;
const tslib_1 = require("tslib");
const webpack_dev_server_1 = tslib_1.__importDefault(require("webpack-dev-server"));
const bundler_1 = require("@forge/bundler");
const resource_tunnel_server_1 = require("./resource-tunnel-server");
const cli_shared_1 = require("@forge/cli-shared");
const url_1 = require("url");
class NativeUITunnelServer extends resource_tunnel_server_1.ResourceTunnelServer {
    constructor(tunnelArgs) {
        super(tunnelArgs);
        this.tunnelArgs = tunnelArgs;
        const { key, path, port, permissions, remotes } = tunnelArgs;
        const entrypoint = { name: key, path, functions: [] };
        const config = (0, bundler_1.getNativeUiBuildConfig)([entrypoint]);
        const compiler = (0, bundler_1.getCompiler)(Object.assign(Object.assign({}, config), { infrastructureLogging: {
                level: 'error'
            }, stats: 'errors-only', watchOptions: {
                aggregateTimeout: 200,
                poll: 1000,
                ignored: '**/node_modules'
            } }));
        this.server = new webpack_dev_server_1.default({
            port,
            host: process.env.FORGE_DEV_TUNNEL ? 'localhost' : '0.0.0.0',
            setupMiddlewares: (middlewares) => {
                const index = middlewares.findIndex((middleware) => middleware.name === 'webpack-dev-middleware');
                middlewares.splice(index, 0, {
                    name: 'custom-ui-scripts-middleware',
                    middleware: this.getCustomUIHtmlTransformMiddleware(permissions, remotes)
                });
                middlewares.unshift({
                    name: 'logging-middleware',
                    middleware: (req, _, next) => {
                        this.logFileServed(req.url, (input) => cli_shared_1.Text.tunnel.customUI.fileServed(input, this.key));
                        next();
                    }
                });
                return middlewares;
            }
        }, compiler);
    }
    async start() {
        const { key, port } = this.tunnelArgs;
        return {
            port,
            devServer: this,
            resourceKey: key,
            tunnelUrl: new url_1.URL(`http://localhost:${port}`)
        };
    }
    async compileAndWatch({ onBuildWillStart, onBuildFinished }) {
        await this.server.start();
        const compiler = this.server.compiler;
        compiler.hooks.watchRun.tapAsync('watchRun', async (_, watchRunCallback) => {
            await onBuildWillStart();
            watchRunCallback();
        });
        let isFirtCompilation = true;
        return new Promise((resolve, reject) => {
            compiler.hooks.done.tapAsync('done', async (stats, doneCallback) => {
                const maybeError = stats.hasErrors() ? stats.compilation.getErrors()[0] : undefined;
                try {
                    (0, bundler_1.handleWebpackCompilationResult)(this.logger, maybeError, stats);
                    this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.resourcesBundlingSucceeded));
                    if (!isFirtCompilation) {
                        await onBuildFinished(null);
                    }
                    else {
                        isFirtCompilation = false;
                    }
                    resolve({});
                }
                catch (err) {
                    await onBuildFinished(err);
                    isFirtCompilation = false;
                    reject(err);
                }
                finally {
                    doneCallback();
                }
            });
        });
    }
    async stop() {
        return this.server.stop();
    }
}
exports.NativeUITunnelServer = NativeUITunnelServer;
