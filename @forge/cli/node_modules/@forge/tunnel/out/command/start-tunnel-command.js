"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartTunnelCommand = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const runtime_1 = require("@forge/runtime");
const node_cache_1 = tslib_1.__importDefault(require("node-cache"));
const servers_1 = require("../servers");
const index_1 = require("../index");
class StartTunnelCommand {
    constructor(getAppConfig, devServer, tunnelFactory, tunnelClient, functionHost, inspector, logger, configFile) {
        this.getAppConfig = getAppConfig;
        this.devServer = devServer;
        this.tunnelFactory = tunnelFactory;
        this.tunnelClient = tunnelClient;
        this.functionHost = functionHost;
        this.inspector = inspector;
        this.logger = logger;
        this.configFile = configFile;
        this.tunnelServers = {};
        this.stopServices = async (appId, environmentKey) => {
            var _a;
            await Promise.all([
                this.functionHost.stopWatching(),
                this.tunnelClient.unregisterTunnels(appId, environmentKey),
                this.tunnelFactory.closeTunnel(),
                this.devServer.stop(),
                this.inspector.stopServer(),
                ...Object.values(this.tunnelServers).map((server) => server.stop()),
                (_a = this.cspReporterServer) === null || _a === void 0 ? void 0 : _a.stop()
            ]);
        };
        this.startFaaSTunnelServer = async (port) => {
            const { permissions = {}, remotes = [] } = await this.configFile.readConfig();
            const serverInfo = await this.devServer.start(port, permissions, remotes);
            const faasTunnelUrl = await this.tunnelFactory.establishTunnel(serverInfo.port);
            return Object.assign(Object.assign({}, serverInfo), { tunnelUrl: faasTunnelUrl });
        };
        this.startResourceBasedTunnelsServers = async (resourceDetails, options) => {
            var _a, _b, _c;
            const portMap = (_a = options.resourcePortMap) !== null && _a !== void 0 ? _a : JSON.parse((_b = process.env.RESOURCE_PORT_MAP) !== null && _b !== void 0 ? _b : '{}');
            const { permissions = {}, remotes = [] } = await this.configFile.readConfig();
            const cspReporterPort = parseInt((_c = process.env.CSP_REPORTER_PORT) !== null && _c !== void 0 ? _c : '4000', 10);
            if (resourceDetails.length === 0)
                return [];
            this.cspReporterServer = new servers_1.CspReporterServer(cspReporterPort, this.logger, new node_cache_1.default());
            await this.cspReporterServer.start();
            return await Promise.all(resourceDetails.map(async (rd) => {
                const { key, resourceType } = rd;
                const port = portMap[key];
                const tunnelServer = resourceType === 'nativeUI' ? servers_1.NativeUITunnelServer : servers_1.CustomUITunnelServer;
                this.tunnelServers[key] = new tunnelServer(Object.assign(Object.assign({}, rd), { port, host: options.host, logger: this.logger, cspReporterServerPort: cspReporterPort, permissions,
                    remotes }));
                return this.tunnelServers[key].start();
            }));
        };
    }
    async execute(options) {
        const { id: appId } = await this.getAppConfig();
        const { port, environmentKey } = options;
        const allResources = await this.configFile.getResources();
        try {
            const faasTunnelServer = await this.startFaaSTunnelServer(port);
            const customUITunnelsServers = await this.startResourceBasedTunnelsServers(allResources, options);
            const tunnelDefinitions = {
                faasTunnelUrl: faasTunnelServer.tunnelUrl,
                customUI: customUITunnelsServers.map(({ tunnelUrl, resourceKey }) => ({
                    tunnelUrl,
                    resourceKey
                }))
            };
            await this.tunnelClient.registerTunnels(appId, environmentKey, tunnelDefinitions);
            const inspectorAddress = (0, index_1.isInspectorEnabled)() ? this.inspector.startServer(index_1.INSPECTOR_PORT) : undefined;
            const stopFunction = async () => this.stopServices(appId, environmentKey);
            const reloadSandboxes = async (bundledCode) => {
                await this.functionHost.stopWatching();
                try {
                    await this.functionHost.startWatching(bundledCode);
                }
                catch (e) {
                    if (e instanceof runtime_1.SnapshotCodeError) {
                        this.logger.error(new Error(cli_shared_1.Text.snapshot.error('App code snapshot error', e.message)));
                    }
                    else {
                        throw e;
                    }
                }
            };
            return {
                localPort: faasTunnelServer.port,
                tunnelDefinitions,
                inspectorAddress,
                stopFunction,
                reloadSandboxes,
                devServers: [faasTunnelServer.devServer, ...customUITunnelsServers.map(({ devServer }) => devServer)]
            };
        }
        catch (e) {
            try {
                await this.stopServices(appId, environmentKey);
            }
            catch (_a) { }
            throw e;
        }
    }
}
exports.StartTunnelCommand = StartTunnelCommand;
