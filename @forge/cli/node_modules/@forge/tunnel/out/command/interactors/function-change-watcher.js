"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalFunctionHost = exports.MEMORY_LIMIT = exports.INVOCATION_TIMEOUT = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const fs_1 = require("fs");
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const cli_shared_1 = require("@forge/cli-shared");
const runtime_1 = require("@forge/runtime");
const util_1 = require("../../util");
exports.INVOCATION_TIMEOUT = 25;
exports.MEMORY_LIMIT = 256;
class LocalFunctionHost {
    constructor(configFile, logger, snapshot, createSandbox) {
        this.configFile = configFile;
        this.logger = logger;
        this.snapshot = snapshot;
        this.createSandbox = createSandbox;
        this.snapshotLogs = [];
        this.onRuntimeLog = (event) => {
            this.logger.info((0, util_1.formatRuntimeLog)(event));
        };
    }
    async generateBundleFiles(bundle, withSnapshot) {
        await fs_1.promises.mkdir((0, path_1.dirname)(bundle.bundleFilePath), { recursive: true });
        if (withSnapshot) {
            if (!this.snapshot) {
                throw new Error('Snapshot requested but snapshot creator not provided.');
            }
            const snapshotOutput = await this.snapshot({ isolateMemory: exports.MEMORY_LIMIT }, Buffer.from(bundle.bundleFileContent), bundle.bundleFilePath, bundle.bundleFileSourceMap ? Buffer.from(bundle.bundleFileSourceMap) : undefined);
            await fs_1.promises.writeFile(bundle.bundleFilePath + '.snapshot', Buffer.from(snapshotOutput.buffer));
            if (snapshotOutput.logs.length > 0) {
                this.snapshotLogs.push(snapshotOutput.logs);
            }
        }
        else {
            await fs_1.promises.writeFile(bundle.bundleFilePath, bundle.bundleFileContent);
        }
        if (bundle.bundleFileSourceMap) {
            await fs_1.promises.writeFile(bundle.bundleFileSourceMapPath, bundle.bundleFileSourceMap);
        }
    }
    async startWatching(bundledCode) {
        const directory = tmp_1.default.dirSync({ prefix: 'tunnel' }).name;
        const isSnapshotEnabled = (await this.configFile.snapshotsEnabled()) && !((await this.configFile.runtimeType()) === cli_shared_1.RuntimeType.nodejs);
        if (isSnapshotEnabled) {
            this.logger.info('');
            this.logger.info(cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.tunnel.snapshotting));
            this.snapshotLogs = [];
        }
        const bundles = Object.keys(bundledCode.output).map((bundleName) => {
            var _a;
            return ({
                bundleFilePath: (0, path_1.resolve)(directory, `${bundleName}.js`),
                bundleFileContent: bundledCode.output[bundleName],
                bundleFileSourceMapPath: (0, path_1.resolve)(directory, `${bundleName}.js.map`),
                bundleFileSourceMap: (_a = bundledCode.sourceMap) === null || _a === void 0 ? void 0 : _a[bundleName]
            });
        });
        const manifestFilePath = (0, path_1.resolve)(directory, cli_shared_1.manifestFileName);
        const manifestContents = JSON.stringify(await this.configFile.readConfig());
        const allPromises = [];
        bundles.forEach((bundle) => allPromises.push(this.generateBundleFiles(bundle, isSnapshotEnabled)));
        allPromises.push(fs_1.promises.writeFile(manifestFilePath, manifestContents));
        await Promise.all(allPromises);
        if (isSnapshotEnabled) {
            if (this.snapshotLogs.length > 0) {
                this.logger.info('');
                this.snapshotLogs.forEach((snapshotLog) => {
                    snapshotLog.forEach((log) => {
                        this.logger.snapshotLog(log.message, (0, util_1.mapLogLevel)(log.level));
                    });
                });
                this.logger.info('');
            }
            else {
                this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.snapshottingNoLogs));
                this.logger.info('');
            }
        }
        await this.initializeSandboxes(directory);
        runtime_1.StaticInvocationEventEmitter.addListener(runtime_1.EVENT_P3_LOG, this.onRuntimeLog);
    }
    async stopWatching() {
        runtime_1.StaticInvocationEventEmitter.removeAllListeners();
    }
    async initializeSandboxes(srcPath) {
        try {
            const handlers = await this.configFile.getAppHandlers();
            const sandboxes = {};
            await Promise.all(handlers.map(async ({ module, func }) => {
                sandboxes[`${module}.${func}`] = await this.createSandbox({
                    modName: module,
                    appPath: srcPath,
                    handler: func,
                    timeout: exports.INVOCATION_TIMEOUT,
                    isolateMemory: exports.MEMORY_LIMIT
                });
            }));
            util_1.SandboxesContainer.updateSandboxes(sandboxes);
        }
        catch (error) {
            this.logger.error(error);
        }
    }
}
exports.LocalFunctionHost = LocalFunctionHost;
