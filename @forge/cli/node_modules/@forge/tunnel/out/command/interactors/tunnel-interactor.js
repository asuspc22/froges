"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelInteractor = void 0;
const tslib_1 = require("tslib");
const readline_1 = tslib_1.__importDefault(require("readline"));
const bundler_1 = require("@forge/bundler");
const cli_shared_1 = require("@forge/cli-shared");
const multi_compiler_watcher_1 = require("./multi-compiler-watcher");
class TunnelInteractor {
    constructor(logger) {
        this.logger = logger;
        this.watchApp = async (startTunnelResult) => {
            const { localPort, inspectorAddress, reloadSandboxes, devServers } = startTunnelResult;
            if (inspectorAddress) {
                this.logger.info(cli_shared_1.Text.tunnel.startedInspector(inspectorAddress));
            }
            const onBundlingStart = async () => {
                try {
                    this.logger.info('');
                    this.logger.info(cli_shared_1.Text.bundle.detectedChanges);
                    await (0, bundler_1.runLinter)();
                    this.logger.info(cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.tunnel.bundlingHeader));
                }
                catch (err) {
                    throw err;
                }
            };
            const onBundlingFinish = async (err, output) => {
                if (err) {
                    this.logger.error(err);
                    return;
                }
                if (output) {
                    await reloadSandboxes(output);
                }
                this.logger.info('');
                this.logger.info(cli_shared_1.Text.tunnel.startedServer(localPort, this.logger.debugEnabled) + '\n');
            };
            if (devServers.length > 0) {
                const multiCompiler = new multi_compiler_watcher_1.MultiCompilerWatcher(devServers);
                await (0, bundler_1.runLinter)();
                this.logger.info(cli_shared_1.Text.tunnel.preBundleTask(cli_shared_1.Text.tunnel.bundlingHeader));
                try {
                    const output = await multiCompiler.compileAndWatch({
                        onChange: {
                            onBuildWillStart: onBundlingStart,
                            onBuildFinished: onBundlingFinish
                        }
                    });
                    await reloadSandboxes(output);
                    this.logger.info('');
                    this.logger.info(cli_shared_1.Text.tunnel.startedServer(localPort, this.logger.debugEnabled) + '\n');
                }
                catch (_) {
                }
                return multiCompiler;
            }
        };
    }
    handleUserExitEvent(stopFunction, bundleMonitor) {
        return new Promise((resolve, reject) => {
            const rl = readline_1.default.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            const tunnelCleanupListener = async () => {
                this.logger.info('');
                this.logger.info(cli_shared_1.Text.tunnel.stoppingTunnel);
                try {
                    rl.close();
                    await stopFunction();
                    resolve();
                }
                catch (error) {
                    this.logger.error(error);
                    reject(error);
                }
                finally {
                    if (bundleMonitor) {
                        await bundleMonitor.stop();
                    }
                    this.logger.info(cli_shared_1.LogColor.trace(cli_shared_1.Text.tunnel.stoppedTunnel));
                    process.exit();
                }
            };
            rl.on('SIGINT', tunnelCleanupListener);
            rl.on('SIGBREAK', tunnelCleanupListener);
            process.on('SIGTERM', tunnelCleanupListener);
        });
    }
}
exports.TunnelInteractor = TunnelInteractor;
