"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalInvocationService = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../util");
const index_1 = require("../index");
const v4_1 = tslib_1.__importDefault(require("uuid/v4"));
const runtime_1 = require("@forge/runtime");
const cli_shared_1 = require("@forge/cli-shared");
const interactors_1 = require("../command/interactors");
class LocalInvocationService {
    constructor(configFile, logger, inspector) {
        this.configFile = configFile;
        this.logger = logger;
        this.inspector = inspector;
    }
    async invoke(handler, request) {
        this.logger.info('');
        this.logger.info((0, util_1.formatInvocation)(handler, request));
        const sandbox = util_1.SandboxesContainer.get()[handler];
        if (!sandbox) {
            throw new cli_shared_1.ValidationError(cli_shared_1.Text.tunnel.error.handler.notFound(handler));
        }
        const inspect = (0, index_1.isInspectorEnabled)();
        if (inspect && this.inspector.isServerStopped()) {
            const inspectorUrl = this.inspector.startServer(index_1.INSPECTOR_PORT);
            this.logger.info(cli_shared_1.Text.tunnel.startedInspector(inspectorUrl));
        }
        const variables = request.variables || [];
        const isSnapshotEnabled = await this.configFile.snapshotsEnabled();
        const isSnapshotValueFoundAndUpdated = (variables || []).some((variable) => {
            if (variable.key !== 'FUNCTION_IS_SNAPSHOTTED')
                return false;
            variable.value = isSnapshotEnabled.toString();
            return true;
        });
        if (!isSnapshotValueFoundAndUpdated) {
            variables.push({ key: 'FUNCTION_IS_SNAPSHOTTED', value: isSnapshotEnabled.toString(), secure: false });
        }
        const requestId = (0, util_1.getRequestId)(request, (0, v4_1.default)());
        const xenInvocationRequest = (0, runtime_1.xenInvocationRequestFactory)({
            request: Object.assign(Object.assign({}, request), { variables }),
            ctx: { requestId, traceId: requestId, timeout: interactors_1.INVOCATION_TIMEOUT }
        });
        const invocationLimits = (0, runtime_1.perInvocationLimitsTrackerFactory)(xenInvocationRequest);
        const timeout = setTimeout(() => {
            this.logger.warn(cli_shared_1.Text.tunnel.invocationTimeout(interactors_1.INVOCATION_TIMEOUT));
        }, interactors_1.INVOCATION_TIMEOUT * 1000);
        const { body, metrics, success, error } = await (0, runtime_1.invoke)({
            sandbox,
            xenInvocationRequest,
            invocationLimits,
            inspector: inspect ? this.inspector : undefined
        });
        clearTimeout(timeout);
        const reportMetrics = xenInvocationRequest.isFeatureFlagEnabled(runtime_1.XEN_RUNTIME_SHOULD_REPORT_METRICS);
        LocalInvocationService.printMetrics(reportMetrics, metrics, this.logger);
        return reportMetrics ? { body, metrics, success, error } : body;
    }
}
exports.LocalInvocationService = LocalInvocationService;
LocalInvocationService.INTERNAL_METRICS = ['execute.setup-request-context', 'invoke.setup-isolate'];
LocalInvocationService.printMetrics = (shouldReportMetrics, metrics, logger) => {
    if (shouldReportMetrics && (metrics === null || metrics === void 0 ? void 0 : metrics.length)) {
        logger.debug(`Metrics: ${JSON.stringify(metrics.filter((m) => !LocalInvocationService.INTERNAL_METRICS.includes(m.name)), null, 2)}`);
    }
};
