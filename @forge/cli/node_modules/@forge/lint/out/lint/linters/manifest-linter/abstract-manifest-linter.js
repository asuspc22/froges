"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractManifestLinter = void 0;
const manifest_1 = require("@forge/manifest");
const linter_interface_1 = require("../../linter-interface");
const abstract_linter_1 = require("../../abstract-linter");
class AbstractManifestLinter extends abstract_linter_1.AbstractLinter {
    constructor(type, logger) {
        super(logger);
        this.type = type;
    }
    mapManifestResponse(results, fixer) {
        var _a;
        const manifestLintResults = new linter_interface_1.LintResult(manifest_1.MANIFEST_FILE, fixer);
        manifestLintResults.batchAdd(...((_a = this.getResultsForFixer(results).map(({ level, message, line, column, reference, metadata }) => {
            return {
                class: level,
                message,
                reference,
                line,
                column,
                metadata
            };
        })) !== null && _a !== void 0 ? _a : []).sort((a, b) => a.line - b.line));
        return manifestLintResults;
    }
    getProcessor() {
        return this.processor;
    }
    async batchExecuteImpl() {
        if (!this.processor) {
            throw new Error('Bootstrap failed');
        }
        const results = await this.processor.process();
        return [this.mapManifestResponse(results, this.getFixer())];
    }
    bootstrap() {
        this.processor = manifest_1.ProcessorBuilder.instance().withValidation(this.type).build();
        return Promise.resolve();
    }
    getFixer() {
        return undefined;
    }
    getResultsForFixer(results) {
        var _a;
        return ((_a = results.errors) === null || _a === void 0 ? void 0 : _a.filter((error) => !error.metadata)) || [];
    }
}
exports.AbstractManifestLinter = AbstractManifestLinter;
