"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductVerifier = void 0;
const tslib_1 = require("tslib");
const linter_interface_1 = require("../../../linter-interface");
const verifier_interface_1 = require("../../verifier-interface");
const cli_shared_1 = require("@forge/cli-shared");
const manifest_1 = require("@forge/manifest");
const text_1 = require("../../../text");
const array_prototype_flatmap_1 = tslib_1.__importDefault(require("array.prototype.flatmap"));
class ProductVerifier extends verifier_interface_1.BaseLintIssueVerifier {
    constructor(environment, manifest, pathMap, product) {
        super(environment, manifest);
        this.pathMap = pathMap;
        this.product = product;
    }
    getLintClass() {
        return linter_interface_1.LintClass.Error;
    }
    async process(apiCalls) {
        var _a;
        const rules = [];
        const lintCriteriaMatches = new Set();
        for (const apiCall of apiCalls) {
            const apiCallLookupResult = this.lookupApiCall(apiCall);
            if (apiCallLookupResult) {
                lintCriteriaMatches.add(apiCallLookupResult);
            }
        }
        for (const apiCall of lintCriteriaMatches) {
            if (!(apiCall === null || apiCall === void 0 ? void 0 : apiCall.regex)) {
                continue;
            }
            const missingScopes = await this.getMissingPermissionScopes(apiCall);
            for (const permission of missingScopes) {
                rules.push({
                    class: this.getLintClass(),
                    message: text_1.messages.verifiers.product.message((0, cli_shared_1.capitalise)(this.product), apiCall.method.toUpperCase(), (_a = this.pathMap.get(apiCall.regex)) === null || _a === void 0 ? void 0 : _a.originalPath, permission),
                    reference: text_1.messages.verifiers.product.reference,
                    line: apiCall.line,
                    column: apiCall.column,
                    metadata: {
                        missingPermission: permission
                    }
                });
            }
        }
        return rules;
    }
    lookupApiCall(apiCall) {
        const pathWithoutQuery = apiCall.path.replace(/\?.+$/, '');
        for (const regex of this.pathMap.keys()) {
            if (regex.test(pathWithoutQuery)) {
                return Object.assign(Object.assign({}, apiCall), { regex, path: pathWithoutQuery, method: apiCall.method.toLowerCase() });
            }
        }
    }
    getMissingPermissionScopes(apiCall) {
        var _a, _b;
        const current = this.getRequiredScopes(apiCall);
        const beta = this.getBetaScopes(apiCall);
        return (0, manifest_1.getMissingScopes)((_b = (_a = this.manifest) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.scopes, { current, beta });
    }
    getRequiredScopes({ regex, method }) {
        var _a, _b, _c, _d;
        if (!regex)
            return [];
        const oAuth2Scopes = (_b = (_a = this.pathMap.get(regex)) === null || _a === void 0 ? void 0 : _a.methods[method]) === null || _b === void 0 ? void 0 : _b['x-atlassian-oauth2-scopes'];
        if (oAuth2Scopes) {
            return (0, array_prototype_flatmap_1.default)(oAuth2Scopes.filter((scope) => scope.state === 'Current').map((scope) => scope.scopes), (x) => x);
        }
        const swaggerEntries = (_d = (_c = this.pathMap.get(regex)) === null || _c === void 0 ? void 0 : _c.methods[method]) === null || _d === void 0 ? void 0 : _d.security;
        if (!swaggerEntries)
            return [];
        return swaggerEntries === null || swaggerEntries === void 0 ? void 0 : swaggerEntries.reduce((prev, curr) => [...prev, ...(curr['OAuth2'] || []), ...(curr['oAuthDefinitions'] || [])], []);
    }
    getBetaScopes({ regex, method }) {
        var _a, _b;
        if (!regex)
            return [];
        const oAuth2Scopes = (_b = (_a = this.pathMap.get(regex)) === null || _a === void 0 ? void 0 : _a.methods[method]) === null || _b === void 0 ? void 0 : _b['x-atlassian-oauth2-scopes'];
        if (!oAuth2Scopes)
            return [];
        return (0, array_prototype_flatmap_1.default)(oAuth2Scopes.filter((scope) => scope.state === 'Beta').map((scope) => scope.scopes), (x) => x);
    }
}
exports.ProductVerifier = ProductVerifier;
