"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionLinter = exports.fixMissingPermissions = exports.findMissingPermissions = exports.NON_FWD_SLASH_REGEX = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const base_linter_1 = tslib_1.__importDefault(require("../../base-linter"));
const api_call_interface_1 = require("./api-call-interface");
const verifiers_1 = require("./verifiers");
const visitors_1 = require("./visitors");
const fs_1 = tslib_1.__importDefault(require("fs"));
exports.NON_FWD_SLASH_REGEX = '[^\\/\\s]*';
const CACHE_KEY = 'PERMISSIONS_LINTER';
const ONE_HOUR_MS = 1000 * 60 * 60;
const findMissingPermissions = (errors, warnings, permissionsType, state) => {
    const missingPermissions = new Set();
    errors.forEach(({ metadata }) => {
        if (metadata && metadata[permissionsType]) {
            missingPermissions.add(metadata[permissionsType]);
            if (state)
                state.errorsFixed++;
        }
    });
    warnings.forEach(({ metadata }) => {
        if (metadata && metadata[permissionsType]) {
            missingPermissions.add(metadata[permissionsType]);
            if (state)
                state.warningsFixed++;
        }
    });
    return missingPermissions;
};
exports.findMissingPermissions = findMissingPermissions;
const fixMissingPermissions = async (errors, warnings, state) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const missingScopes = (0, exports.findMissingPermissions)(errors, warnings, 'missingPermission', state);
    const missingExternalFetchBackend = (0, exports.findMissingPermissions)(errors, warnings, 'missingExternalFetchPermission', state);
    const missingContentStyle = (0, exports.findMissingPermissions)(errors, warnings, 'missingContentStylePermission', state);
    const missingExternalImage = (0, exports.findMissingPermissions)(errors, warnings, 'missingExternalImagesPermission', state);
    const currentPermissions = (_b = (_a = (await state.configFile.readConfig())) === null || _a === void 0 ? void 0 : _a.permissions) !== null && _b !== void 0 ? _b : {};
    const currentRemotes = (_d = (_c = (await state.configFile.readConfig())) === null || _c === void 0 ? void 0 : _c.remotes) !== null && _d !== void 0 ? _d : [];
    const currentScopes = (_e = currentPermissions === null || currentPermissions === void 0 ? void 0 : currentPermissions.scopes) !== null && _e !== void 0 ? _e : [];
    currentScopes.forEach((e) => missingScopes.add(e));
    const currentExternalFetchBackend = (_h = (_g = (_f = currentPermissions === null || currentPermissions === void 0 ? void 0 : currentPermissions.external) === null || _f === void 0 ? void 0 : _f.fetch) === null || _g === void 0 ? void 0 : _g.backend) !== null && _h !== void 0 ? _h : [];
    currentExternalFetchBackend
        .map((item) => {
        var _a;
        if (typeof item === 'string')
            return item;
        return (_a = currentRemotes.find((remote) => remote.key == item.remote)) === null || _a === void 0 ? void 0 : _a.baseUrl;
    })
        .filter((item) => typeof item === 'string')
        .forEach((e) => missingExternalFetchBackend.add(e));
    const arrayMissingExternalFetchBackend = [...missingExternalFetchBackend];
    const currentContentStyles = (_k = (_j = currentPermissions === null || currentPermissions === void 0 ? void 0 : currentPermissions.content) === null || _j === void 0 ? void 0 : _j.styles) !== null && _k !== void 0 ? _k : [];
    currentContentStyles.forEach((e) => missingContentStyle.add(e));
    const arrayMissingContentStyles = [...missingContentStyle];
    const currentExternalImages = (_m = (_l = currentPermissions === null || currentPermissions === void 0 ? void 0 : currentPermissions.external) === null || _l === void 0 ? void 0 : _l.images) !== null && _m !== void 0 ? _m : [];
    currentExternalImages.forEach((e) => missingExternalImage.add(e));
    const arrayMissingExternalImages = [...missingExternalImage];
    const config = Object.assign(Object.assign({}, currentPermissions), { scopes: [...missingScopes] });
    if (arrayMissingExternalFetchBackend.length > 0) {
        config.external = Object.assign(Object.assign({}, config.external), { fetch: Object.assign(Object.assign({}, (_o = config.external) === null || _o === void 0 ? void 0 : _o.fetch), { backend: arrayMissingExternalFetchBackend }) });
    }
    if (arrayMissingExternalImages.length > 0) {
        config.external = Object.assign(Object.assign({}, config.external), { images: arrayMissingExternalImages });
    }
    if (arrayMissingContentStyles.length > 0) {
        config.content = Object.assign(Object.assign({}, config.content), { styles: arrayMissingContentStyles });
    }
    await state.configFile.writeToConfigFile('permissions', config);
    return state;
};
exports.fixMissingPermissions = fixMissingPermissions;
class PermissionLinter extends base_linter_1.default {
    constructor(environment, manifest, logger) {
        super(environment, logger);
        this.manifest = manifest;
    }
    async bootstrap() {
        this.cache = cli_shared_1.CachedConf.getCache(CACHE_KEY);
        const LOCAL_CONF_SWAGGER = process.env.LOCAL_CONF_SWAGGER;
        const LOCAL_JIRA_SWAGGER = process.env.LOCAL_JIRA_SWAGGER;
        const LOCAL_JSM_SWAGGER = process.env.LOCAL_JSM_SWAGGER;
        const LOCAL_JSW_SWAGGER = process.env.LOCAL_JSW_SWAGGER;
        const USE_LOCAL_SWAGGER = process.env.USE_LOCAL_SWAGGER;
        let swaggerFiles;
        if (USE_LOCAL_SWAGGER && LOCAL_CONF_SWAGGER && LOCAL_JIRA_SWAGGER && LOCAL_JSM_SWAGGER && LOCAL_JSW_SWAGGER) {
            swaggerFiles = [
                this.getProductPathsFile(LOCAL_JIRA_SWAGGER),
                this.getProductPathsFile(LOCAL_JSM_SWAGGER),
                this.getProductPathsFile(LOCAL_JSW_SWAGGER),
                this.getProductPathsFile(LOCAL_CONF_SWAGGER)
            ];
        }
        else {
            swaggerFiles = [
                this.getProductPaths(PermissionLinter.JIRA_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/platform/swagger-v3.v3.json'),
                this.getProductPaths(PermissionLinter.JSM_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/service-desk/swagger.v3.json'),
                this.getProductPaths(PermissionLinter.JSW_CACHE_KEY, 'https://developer.atlassian.com/cloud/jira/software/swagger.v3.json'),
                this.getProductPaths(PermissionLinter.CONFLUENCE_CACHE_KEY, 'https://developer.atlassian.com/cloud/confluence/swagger.v3.json')
            ];
        }
        const [jiraSwagger, jsmSwagger, jswSwagger, confluenceSwagger] = await Promise.all(swaggerFiles);
        this.jira = this.processPaths(Object.assign(Object.assign(Object.assign({}, jiraSwagger.paths), jsmSwagger.paths), jswSwagger.paths));
        this.confluence = this.processPaths(confluenceSwagger.paths);
        this.nodeVisitors = [
            new visitors_1.ProductNodeVisitor(),
            new visitors_1.UIHookNodeVisitor(),
            new visitors_1.StorageAPINodeVisitor(),
            new visitors_1.ExternalApiCallVisitor(),
            new visitors_1.ImageUrlVisitor(),
            new visitors_1.ContentPropertyVisitor()
        ];
        const humanReadableEnvironment = (0, cli_shared_1.environmentToOption)(this.environment);
        this.verifiers = {
            confluence: new verifiers_1.ProductVerifier(humanReadableEnvironment, this.manifest, this.confluence, 'confluence'),
            jira: new verifiers_1.ProductVerifier(humanReadableEnvironment, this.manifest, this.jira, 'jira'),
            storage: new verifiers_1.StorageAPIVerifier(humanReadableEnvironment, this.manifest),
            uiHook: new verifiers_1.UIHookVerifier(humanReadableEnvironment, this.manifest),
            external: new verifiers_1.ExternalFetchVerifier(humanReadableEnvironment, this.manifest),
            image: new verifiers_1.ImageUrlVerifier(humanReadableEnvironment, this.manifest),
            contentProperty: new verifiers_1.ContentPropertyVerifier(humanReadableEnvironment, this.manifest)
        };
    }
    setupMatchesMap(filepath) {
        if (!this.jira || !this.confluence)
            throw new Error('Bootstrap failed');
        this.matches.set(filepath, {
            confluence: [],
            jira: [],
            uiHook: [],
            storage: [],
            external: [],
            image: [],
            contentProperty: []
        });
    }
    getFixer() {
        return exports.fixMissingPermissions;
    }
    addLintCriteriaMatch(apiCall, filepath) {
        const criteriaMatches = this.matches.get(filepath);
        switch (apiCall.type) {
            case api_call_interface_1.ApiCallTypes.PRODUCT:
                criteriaMatches[apiCall.product].push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.HOOK:
                criteriaMatches.uiHook.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.STORAGE:
                criteriaMatches.storage.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.EXTERNAL:
                criteriaMatches.external.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.IMAGE:
                criteriaMatches.image.push(apiCall);
                break;
            case api_call_interface_1.ApiCallTypes.CONTENT_PROPERTY:
                criteriaMatches.contentProperty.push(apiCall);
                break;
        }
    }
    async getProductPaths(cacheKey, url) {
        var _a, _b;
        const cached = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(cacheKey);
        if (!cached) {
            const response = await (0, node_fetch_1.default)(url);
            const jsonBody = await response.json();
            void ((_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(cacheKey, jsonBody, 12 * ONE_HOUR_MS));
            return jsonBody;
        }
        return cached;
    }
    async getProductPathsFile(url) {
        const response = fs_1.default.readFileSync(url);
        return JSON.parse(response.toString());
    }
    processPaths(paths) {
        const pathMap = new Map();
        Object.keys(paths).forEach((path) => {
            const key = new RegExp(path.replace(/{(?<={)(.*?)(?=})}/g, exports.NON_FWD_SLASH_REGEX) + '\\/?$');
            pathMap.set(key, { originalPath: path, methods: paths[path] });
        });
        return pathMap;
    }
}
exports.PermissionLinter = PermissionLinter;
PermissionLinter.JIRA_CACHE_KEY = 'permissions-jira-cache-key';
PermissionLinter.JSM_CACHE_KEY = 'permissions-jsm-cache-key';
PermissionLinter.JSW_CACHE_KEY = 'permissions-jsw-cache-key';
PermissionLinter.CONFLUENCE_CACHE_KEY = 'permissions-confluence-cache-key';
