"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerLinter = void 0;
const tslib_1 = require("tslib");
const cli_shared_1 = require("@forge/cli-shared");
const base_linter_1 = tslib_1.__importDefault(require("../../base-linter"));
const handlers_verifier_1 = require("./verifiers/handlers-verifier");
const visitors_1 = require("./visitors");
class HandlerLinter extends base_linter_1.default {
    constructor(environment, manifest, logger) {
        super(environment, logger);
        this.manifest = manifest;
        this.getHandlerFileRegex = (fileName) => new RegExp(`^src(\/|\\\\)${fileName}\.[tj](s|sx)$`);
    }
    async bootstrap() {
        this.nodeVisitors = [new visitors_1.ExportedFunctionNodeVisitor()];
        const humanReadableEnvironment = (0, cli_shared_1.environmentToOption)(this.environment);
        this.verifiers = {
            functionHandlers: new handlers_verifier_1.HandlersVerifier(humanReadableEnvironment, this.manifest)
        };
    }
    getFunctionHandlers(manifest) {
        var _a, _b, _c;
        return (_c = (_b = (_a = manifest.modules) === null || _a === void 0 ? void 0 : _a.function) === null || _b === void 0 ? void 0 : _b.filter((funcs) => funcs.handler && funcs.handler.split('.').length === 2)) === null || _c === void 0 ? void 0 : _c.map((funcs) => {
            const [file, method] = funcs.handler.split('.');
            return {
                file,
                method,
                key: funcs.key
            };
        }).filter((handler) => handler.method && handler.file);
    }
    setupMatchesMap(filepath) {
        const handlers = this.getFunctionHandlers(this.manifest);
        const filteredHandlers = handlers === null || handlers === void 0 ? void 0 : handlers.filter((handler) => this.getHandlerFileRegex(handler.file).test(filepath));
        this.matches.set(filepath, {
            functionHandlers: {
                expectedMethods: filteredHandlers || [],
                exportedMethods: []
            }
        });
    }
    filterLintInput(inputs) {
        const handlers = this.getFunctionHandlers(this.manifest);
        return inputs.filter((input) => handlers === null || handlers === void 0 ? void 0 : handlers.find((handler) => this.getHandlerFileRegex(handler.file).test(input.filepath)));
    }
    addLintCriteriaMatch(exportedMethod, filepath) {
        const criteriaMatches = this.matches.get(filepath);
        criteriaMatches.functionHandlers.exportedMethods.push(exportedMethod);
    }
}
exports.HandlerLinter = HandlerLinter;
