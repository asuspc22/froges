"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_shared_1 = require("@forge/cli-shared");
const linter_interface_1 = require("./linter-interface");
const abstract_linter_1 = require("./abstract-linter");
class BaseLinter extends abstract_linter_1.AbstractLinter {
    constructor(environment, logger) {
        super(logger);
        this.environment = environment;
        this.logger = logger;
        this.nodeVisitors = [];
        this.matches = new Map();
        this.verifiers = {};
    }
    getFixer() {
        return undefined;
    }
    filterLintInput(inputs) {
        return inputs;
    }
    traverse(ast, filepath) {
        ast.traverse({
            enter: (node, parent) => {
                this.nodeVisitors.forEach((visitor) => visitor.visit(node, parent, (t) => this.addLintCriteriaMatch(t, filepath)));
            }
        });
    }
    async verifyLintCriteriaMatches(lintCriteriaMatches) {
        const lintIssues = await Promise.all(Object.entries(lintCriteriaMatches).map(async ([matchCategory, matches]) => {
            return this.verifiers[matchCategory].process(matches);
        }));
        return (0, cli_shared_1.flat)(lintIssues);
    }
    async execute({ ast, filepath, fixer }) {
        const lintResult = new linter_interface_1.LintResult(filepath, fixer);
        if (!ast)
            return lintResult;
        this.setupMatchesMap(filepath);
        if (!this.matches.size) {
            throw new Error('Matches not set');
        }
        if (!this.nodeVisitors.length) {
            throw new Error('Visitors not set');
        }
        if (!Object.keys(this.verifiers).length) {
            throw new Error('Verifiers not set');
        }
        this.traverse(ast, filepath);
        const matchesForFile = this.matches.get(filepath);
        if (!matchesForFile)
            return lintResult;
        const lintIssues = await this.verifyLintCriteriaMatches(matchesForFile);
        lintResult.batchAdd(...lintIssues);
        return lintResult;
    }
    batchExecuteImpl(inputs) {
        return Promise.all(this.filterLintInput(inputs).map(({ ast, filepath }) => this.execute({ ast, filepath, fixer: this.getFixer() })));
    }
}
exports.default = BaseLinter;
